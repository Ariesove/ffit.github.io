{"meta":{"title":"Hexo","subtitle":"","description":"","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[],"posts":[{"title":"异步理解","slug":"异步","date":"2020-12-29T12:22:00.000Z","updated":"2021-02-24T13:15:48.092Z","comments":true,"path":"2020/12/29/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/29/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending new/创建 一个promise后的状态 fulfilled 调用promise.resolve()的方法后 rejected 异步任务出错/或是抛出异常后//但是如果仅仅是return 了一个错误对象，也是不行的 调用promise.reject() 不同状态所触发的方法 then() 首先当promise对象为fullfiled时会触发 里面只能接收一个函数，其它类型一律无视 并且会返回一个新的fullfiled(一般情况下，如果throw了一个错误)promise对象 这也解答了自己一个疑惑就是说，为什么then可以链式来调用，不是状态只能变一次吗，其实是因为又新建了一个新的promise对象 catch() 当状态为rejected时触发 返回了一个具有fullfiled状态的promise对象 finally 无论什么状态，最终都会执行的函数 谨记一点就是 promise的状态的改变是不可逆的 一旦成为fullfilled状态，或是rejected状态 即便是同状态的改变也不可以 核心 状态仅能改变一次 再具体一点就是说，一旦状态变了，后续,resolve(),reject()方法全部失效 有哪些方法 resolve(value) 成功 Subtopic value是一个带有then()方法的对象 由then()方法所返回状态来决定 从这可以看出来，then()方法返回的并不一定是成功的状态 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务 它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 那么为什么要有异步有些网络请求实在是太耗费时间了，如果不引入异步机制的话会浪费时间，用同步的话，只要第一个任务没完成后面的任务全部阻塞了哪些属于异步任务settimeout()dom事件AJAX/AXIOS请求setinterval()回调函数 先明确一下什么是回调函数 就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数 那它和异步有什么关系 回调函数能够获得异步任务的结果","categories":[],"tags":[],"keywords":[]},{"title":"HTTPS基础","slug":"HTTPS","date":"2020-12-25T14:22:00.000Z","updated":"2021-02-24T13:17:08.438Z","comments":true,"path":"2020/12/25/HTTPS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/25/HTTPS/","excerpt":"","text":"HTTPS复盘HTTPS对称加密 其实就是说用同一个经过交换的公钥来加密信息 弊端：交换过程容易被中间人所攻击 非对称加密 其实就是用公钥加密，私钥解密 服务器（公钥a-私钥a)先将公钥a发给客户端，客户端拿到公钥a后加密自己生成一个随机数，然后再发给服务器，服务器再拿私钥a来解密公钥a所加密的随机数 之后再去用这个随机数充当之后对称加密的公钥 TLS握手阶段/ECDHE算法 一阶段 客户端 client hello 支持的TLS协议版本号 支持的密码套件 Client Random 服务器 server random 确认TLS协议版本号 确认选取某个密码套件 Server Random 二阶段 此时服务器为了能够验证自己的身份,向客户端发送证书（里面包含着服务器给客户端所发的公钥） 以ECDHE举例：之后服务器还会发给客户端一个Server params 用于密钥交换算法 密钥交换阶段 客户端 此时收到证书，先验签证明是如期的通信方后，取出证书里的公钥，同时生成一个Client Params,发给服务器，此时双方基于ECDHE算法（client params server params )生成Pre-master 对称加密的过程 客户端 此时拥有三个随机数 client random server random pre-master 服务器 同理也生成了一个Master Secret 之后双方拿这个Master随机数来加密finished 信息代表握手结束，之后就拿这个Master来当对称密钥，来进行之后的对称加密 默认端口443不可否认性TLS密钥交换算法签名算法对称加密算法摘要算法身份验证子主题完整性由于黑客可能窃取足够多的密文，并改造，重组再发给服务器，此时如果无法保证信息的完整性，服务器只能全盘接收依据其响应反推密文，所以此时要来保证信息的完整性摘要算法 单向将密文压缩为独一无二的摘要 SHA-2 常用算法 特点 单向性 无法由摘要反推密文 雪崩效应 微小的改变都会造成极大的改变，避免黑客篡改信息 具体应用就是说 此时客户端发送用会话密钥加密的消息以及对应的摘要 服务器接收并用会话密钥解密后，拿到信息，自己再用SHA-2算法生成摘要来比对对方的摘要，无变动说明没有改动 机密性对称加密 用同一个公钥加密和解密 常用算法 chacha20 AES 分组模式 将密钥转化为密文 密钥加密明文转换为密文 非对称加密 通俗来讲网站保管私钥，网上分发公钥 公钥加密，私钥解密 单向性 解决了对称加密中密钥交换的安全性 常用算法 RSA 基于整数分解的数学难题 ECC 基于椭圆曲线离散对数 ECDHE子算法 用于密钥交换 弊端就是由于基于各种数学难题，所以运算速度极慢 所以HTTPS采用混合加密","categories":[],"tags":[],"keywords":[]},{"title":"tcp简要总结","slug":"TCP","date":"2020-12-23T14:12:00.000Z","updated":"2021-02-24T13:17:33.991Z","comments":true,"path":"2020/12/23/TCP/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/23/TCP/","excerpt":"","text":"TCP这一次首先复习一下TCP重传机制为什么TCP会重传呢 TCP建立连接的过程如果这个过程如果有丢包那么就会触发重传机制 超时重传 就是TCP内部有一个机制会设定一个时间（时延）这个时间大概略大于，tcp报文往返时间，这个时间的设置不能太短，如果太短那报文还没来的及发回来就误认为包丢了，导致重传，但是也不能设置的太长，这个会造成网络资源浪费（为什么会造成资源浪费我来解释一下：就是说如果时间设置太长了，此时真的发生丢包了，那客户端等很久之后才重发，那不是很浪费网路资源嘛对吧； 快速重传 为什么已经有了超时重传：还要有快速重传 其实是这样，就是说，由于超时重传，是要等一段时间才重传，其实效率并不是很高，所以网络设计们采取了快速重传机制这样效率更高 什么时候会触发快速重传机制，比如此时发送方发送了三个数据包（1，2，3），其中2没有发送出去，接收方只发出基于第一个数据包的确认号，并且重复了三次（不包含第一次的确认，再此基础上，再来三次确认）这个确认号，就是告诉发送方，2这个数据包丢失了，需要对方重新发送，于是触发了发送方的快速重传机制，发送方会重新传送2这个丢失数据包 特点 接受方会重复发送丢失包的确认号 缺点 这里存在一个问题就是，发送方是依据所收到的确认号，来确认接受方是否收到了数据，但是此时发送方只接受到了丢失包的确认号，它也不知道之后的数据包到底发送成功没；————于是Sack就是来解决这个问题的 SACK 这里我通俗来讲一下，就是说为了能够让对方知道自己到底具体传哪些丢失的数据包，每次服务器发来的确认号，还会带上服务器已收到的最大 连续的包的序列号 滑动窗口为什么要有滑动窗口 为了提升网络传输效率 原因在于tcp为了能够实现可靠信息的传输：为每一个数据包都进行确认，那么这就导致了，数据包往返时间越长，网路通信效率就会大幅度的降低（不是很理解网络吞吐量），所以才引用到了窗口 怎么做的：就是为tcp报文设立一个滑动窗口，这个滑动窗口的大小由服务器决定/并且，是无需等待对方的确认，而可以继续发送的数据包 发送窗口 已收到确认的序列号 已经发送但未收到确认的序列号（这个窗口的尺寸大小是服务器能接受的） 还有一段未发送，但在接收方能力范围内的数据段（又称可用窗口的大小）（未发送但是可发送的包） 超出了服务器所能接受的序列号 接收方滑动窗口 已收到数据，并且已经确认的数据段 未收到数据但是可以接受的窗口大小 未收到数据但是无法确认的数据段 那有一个问题就是如果中途其中一个确认号丢失了，怎么办 滑动窗口中的序列号是有序的，这也就意味着确认号也是有序的，只要缺失的那个序列号的确认号之后的确认号得到了确认，那么就是一种累计确认，只要某个确认号确认后默认之前的所有序列号都得到了确认（这里我对于序列号不是很理解） 滑动窗口是怎么个滑动法 就是服务器发来确认号后，发送方的滑动窗口相应的就会滑动和确认号序列相同的距离，意味着可用窗口增加了 补充：滑动窗口大小的含义：指的是发送方不必等待对方的确认，可以发送的最大报文段 流量控制就是来控制发送方发送数据的速率，防止超出接收方处理接收数据的能力依赖于滑动窗口 意思就是通过告知发送方自己的接收窗口大小rwnd来，控制发送方的数据–从而实现了流量控制 那所谓的窗口是什么：就是接收方最大所能处理的数据量窗口关闭 主要就是在接收方发送给发送方自己最新的接收窗口大小的时候，发生了丢失–tcp的可靠传输没有对窗口大小的消息产生作用 双方都在等待对方 拥塞控制拥塞控制主要是避免发送方不断的发送数据而导致网络拥塞那为了避免拥塞，需要客户端维护一个拥塞窗口（CWND）ssthresh//阈值有哪些算法 慢开始 就是一开始每当收到一个ack，其cwnd加一个，第二轮收到2个，cwnd就为2，第三轮次收到4个ack，cwnd为4,这样呈现了指数增加 拥塞避免 但是随着客户端发送数据数量的增加 一定会到达阈值 进入拥塞避免后每收到一个确认，cwnd只加1/cwnd，比如当前收到了8个确认，一个加1/8,这次拥塞窗口仅加了一次，之后就是线性增长了 拥塞发生 你即便是再怎么避免，还是会导致网络拥塞 超时重传 进入拥塞避免算法 但是这里有一个问题就是说：每次一进入拥塞避免，拥塞窗口，直接就初始化为1 就算网络不拥堵，但是会卡顿，因为所能发送的数据包骤减 此时客户端认为其实网络情况也没有那么糟糕 ssthresh=cwnd/2 初始化cwnd=1 快重传 cwnd/2 sshred=cwnd/2 快恢复 触发快重传后，紧接着执行 cwnd=ssthred+3(ack报文） 很明显拥塞窗口已经大于阈值了：之后再次进入线性拥塞避免算法","categories":[],"tags":[],"keywords":[]},{"title":"es6基础","slug":"es6","date":"2020-12-15T14:20:00.000Z","updated":"2021-02-24T13:16:51.026Z","comments":true,"path":"2020/12/15/es6/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/15/es6/","excerpt":"","text":"es6promise/generator/async/await箭头函数是什么 function的一种简化 何时用 简化函数，凡是用到函数的时候就可以用 怎么用 无参数 &lt;ol&gt;&lt;li&gt;（）=&gt;{&nbsp; &nbsp;}&lt;br&gt;&lt;/li&gt;&lt;/ol&gt; 有多个参数时 const&nbsp; fun=(a,b,c)=&gt;{&nbsp; return 函数体} 注意要得到函数返回值别把return忘记 正则表达式什么是 限制用户所输入的信息，的表达式 什么时候用 表单验证 用户名输入的时候 子主题 对于密码验证的时候 怎么用 起止符 ^ 开始符号 &amp;结束符 多选一符号 [ ] 组合符号 ^[^A-Z0-9${2,3} ] 后面花括号代表的是从前面选2-3个元素； 作用域块级作用域 const 这个和let的最大的区别就是，const不可以先只声明 为什么 const所定义的是一个定值，如果你只声明不赋值，如何做到是一个定值，感觉有点勉强 let Subtopic 它首先解决了var变量提升的问题 它怎么解决这个问题的，将全局执行上下文的创建阶段和执行阶段时机同步了所以不会再出现变量提升的问题 它还解决了，var没有作用域的问题 由块级作用域，引发了一个问题就是暂时性死区 什么时候会引发暂时性死区 条件 如果在一个块级作用域里存在let,那么此时let所处的作用域就会锁死 一旦在变量let声明前,去使用就会为undefined 那我什么时候能用，只有到声明后才可以去使用let/或const所声明的变量 那具体暂时性死区是什么 其实就是let/const声明前的代码区域（在块级作用域中） var 没有块级作用域 那如果没有块级作用域会引发哪些问题 在函数中用var声明的变量，函数外部可以访问，这个就很危险 也会引发变量提升的问题 根据你在声明变量的时候，会出现执行上下文，而创建上下文的创建与执行阶段是不同步的所以造成了变量提升 this指向指向谁 在函数 的内部， . . .实现对对象的深拷贝将数组转为由逗号隔开的序列，同时又可以实现拷贝传递形参时用 如果你并不知道参数有几个的时候？？？ 解构怎么用 需要从一些对象（也可解构多层嵌套对象） 说人话 获取对象里的值 根据对象里的键来获取值 更高端大气怎样将类数组转为真正的数组Array.from(类数组)除过es6以外还有什么方法 Array.prototype.slice( ).call(类数组） 这个不理解 Map（）它解决了什么问题 专门用来存储键值对的 什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构那它有哪些方法 set(键，值） 这个返回的是新的map数据结构，包含有新的设置的键值对 has(键） 返回值为布尔值 目的是为了判断是否存在当前键//这个主要判断是否有对应的键 delete(键) 删除键所对应的键值对 get(键） 这个是在获取键所对应的值 这个在力扣第一题中用到它了 Set()一旦题目中涉及集合立刻想到set 特点就是，一旦题目提到有序，无重复元素，立刻反应Set() Set做了哪些事情 给定一个数组 返回一个没有重复序列的集合 能做到什么 数组去重 首先通过，[…set(arry)] 但是我对于这个有一些问题就是，首先通过…元素是否意思是将set数据结构转为数组，那如果已经是数组了为什么要在加上数组字面量不理解 求交集 怎么做","categories":[],"tags":[],"keywords":[]},{"title":"相交链表","slug":"相交链表","date":"2020-12-01T14:22:00.000Z","updated":"2021-02-09T02:06:01.010Z","comments":true,"path":"2020/12/01/相交链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"160. 相交链表。反思 首先这个题的思路就是来联想一下这个相交节点，为什么要用双指针，就是说 a+b+c=b+1+c 也就是说我，都同时开始且路程相同，那么一定会在相交节点，相遇； 因此思路就是只要我能够判断当前的节点是否为空，如果为空了，那就将其接到下一个链表的头节点，如果不为空的话，那就去继续遍历。 自己的不足在于三元表达式不够熟练，就是自己，变量= 条件 ？ a: b ;也就是说只要条件满足执行 a 结果，不满足就执行 b 结果。 12345678910var getIntersectionNode = function(headA, headB) &#123; if(!headA||!headB)&#123;return null&#125; let p1=headA let p2=headB while(p1!==p2)&#123; p1= p1===null? headB:p1.next p2= p2 ===null?headA:p2.next &#125; return p2&#125;; mermaid 注意： 首先这个题只要求节点相同，没有说这个节点的值问题； 其次判断的条件就是这个有一个为空，必然没有相交的节点所以直接，就返回为空就好","categories":[],"tags":[],"keywords":[]},{"title":"V8引擎执行代码","slug":"V8引擎如何执行一段代码","date":"2020-12-01T13:43:45.000Z","updated":"2021-01-12T14:30:52.915Z","comments":true,"path":"2020/12/01/V8引擎如何执行一段代码/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/","excerpt":"","text":"V8 引擎如何执行一段代码编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 全局执行上下文，创建阶段，首先会创建一个全局对象window，创建一个this 然后让它指向这个window，之后为变量和函数分配空间/并且要为变量赋一个undefined，创建作用域链，全局作用域里面有全局变量，全局函数，想来存储对象，不得需要创建存储的空间吗/堆 —栈，事件循环系系统web-api。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于&amp;混合编译执行/解释执行，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率","categories":[],"tags":[],"keywords":[]},{"title":"最长子序列","slug":"最长子序列","date":"2020-12-01T12:20:00.000Z","updated":"2020-12-25T08:46:57.149Z","comments":true,"path":"2020/12/01/最长子序列/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 再次复盘 这道题首先看到了最长，最值问题，动态规划正是在解决，最优子结构，就是说一个问题的最优解，是由许多子问题的最优解组合的，并且这个划分子问题的过程就是降低问题复杂度的过程。 这个题首先分析问题，怎么来分解它降低问题的复杂度，就是倒推思考，求f(i) 前i个元素，并包括，i这个元素的求解，第f(i-1) 这个解，只要知道这个解了那就意味着，知道了f(i)的解，那也就是说要递推求解每一个子序列的最优解，最优子结构； 那就来找状态转移方程：f(n)=maxf(i)+1 //前提是i&lt;n 并且nums[i]的值要小于nums[n]这样才能来延长子序列，否则没有延长的必要二刷反思 这个题就是说，首先自己在做的时候没有考虑好最大长度何时更新，就是说，只有你此时更新的序列只有比之气的最大长度大才有必要更新，否则，不就变小了吗","categories":[],"tags":[],"keywords":[]},{"title":"垃圾回收机制","slug":"垃圾回收机制","date":"2020-11-25T14:14:00.000Z","updated":"2021-02-24T13:16:12.724Z","comments":true,"path":"2020/11/25/垃圾回收机制/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制分类为什么要分类—依据 代际假说 一些变量生存周期很短 存放在新生代区域 一些比如window这些存活时间很长的对象 存放在老生代区域 依据生存周期的长短–因地制宜的选取对应的算法来回收 堆/划分的 目的就是为了能根据不同的对象依据对应的垃圾回收机制，进行回收 新生代 存储生存周期短的对象 区域划分依据scanverge算法 对象区域 空闲区域 老生代 专门存储，生存周期长的对象 主垃圾回收器 专门处理老生代里的对象 算法 标记–整理 标记–清除 步骤 先进行标记–对于清除的对象先进行标记 利用标记–整理算法将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个是让内存空间尽可能的连续 再去清除除过这一端的其它垃圾数据 副垃圾回收机制 scanverge算法 专门处理新生代里存储的对象 步骤 利用标记—清除算法清除对象区域里标记的垃圾数据 在标记–清除阶段将活动对象复制到空闲区域，并进行整理 为的就是能够使存储空间尽可能的连续 对象区域和空闲区域调换 首先来明确一下什么样的变量的空间可以被回收依赖可访问性算法通过GCroot对象遍历内部所有对象 window Dom节点 通过GCroot 对象访问变量 可访问到的：活动对象 不可访问：非活动对象 V8引擎清除的将是非活动对象 在早期有一个局限性较大的垃圾回收机制引用计数法 它具体是怎么做的 每产生一个引用就计数加一 什么是引用？ 那它的局限性在哪 它无法识别循环引用的场景，无法使计数为0; eg:A对象的引用指向B，而B的引用又指向A，它们的引用计数都是1，无法成为0, 就会造成内存泄漏； 为0就会被回收 切入点由数据类型说起基本数据类型 symbol number string 布尔类型 复杂数据类型 function 对象","categories":[],"tags":[],"keywords":[]},{"title":"翻转链表","slug":"反转链表","date":"2020-11-12T14:20:00.000Z","updated":"2021-02-09T02:05:39.939Z","comments":true,"path":"2020/11/12/反转链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表思路（联想三个指针不断的交换） 如实记录几个月后的复盘结果，就是说自己第一次复盘的时候想到了双指针但是自己想的是一个指向了头，一个指向了尾元素，然后交换，思路完全错误了，错在了哪里 首先对撞指针，更适用于两个元素交换，但是这个题的要求是让反转，而且双指针有一个问题就是说，当两个指针进行交换的时候，下一个节点不就丢了吗 引出了三指针进行交换。 题解思路 核心点三指针，每次只通过 cur.next=pre 来循环翻转 并且每次都需要缓存 next 指针为什么，就是因为你每次都翻转完毕后 cur 的 next 指向会丢失，所以你遍历的时候首先就需要来缓存它。 其次还有一个小细节就是为什么，循环的条件没有 next 不为空，因为为空无所谓，但是删除链表这个题考虑下一个元素主要是是因为，都为空了，就没有去重的必要了，也就是说不必去循环了。","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"迭代法先序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2020-11-12T14:37:56.168Z","comments":true,"path":"2020/11/12/迭代法先序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"先来明确一点，为什么一定要用栈，这里我一直遗漏了一点就是 在递归中，再不断调用函数自身的时候，会形成一个调用栈，每调用一次就推入一个函数，执行完毕就去释放？这里不是特别理解理清一下思路（时刻记住其实这个是由递归来改进的） 先设置一个栈结构–为什么为了能够使用栈来模拟调用栈的过程 之后再访问根节点 那怎么来访问根节点，是不是先来入栈，后再来弹出栈，来模拟每调用一次就推入栈，结束后再去弹栈 123456789101112function prorder (root)&#123; const stack&#x3D;[root]; if(!root) &#123;return&#125;; while(stack.length)&#123; const n&#x3D;stack.pop();&#x2F;&#x2F;注意一下这里shift()才是在弹首元素，pop()弹的是尾元素 console.log(n.val); if(n.right) &#123;stack.push(n.right)&#125;; if(n.left) &#123;stack.push(n.left)&#125;; &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"后序遍历","slug":"迭代法后序遍历","date":"2020-11-11T14:20:47.000Z","updated":"2020-11-12T14:37:56.147Z","comments":true,"path":"2020/11/11/迭代法后序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"首先来捋一下思路 后续遍历的顺序是先左子树，再右子树，再根节点 那么从这你思考一下如果我把这个顺序颠倒一下是什么是不是先根节点，再右子树，再左子树，是不是非常的像先序遍历，及就是说把先序遍历的结果再入栈，然后根据栈的先进后出的特性，来得到后序遍历的结果 1234567891011121314151617function lastorder (root) &#123; if(!root)&#123;return&#125; const outstack&#x3D;[]; const stack &#x3D;[root]; while(stack.length)&#123; const n&#x3D;stack.pop(); outstack.push(n) if(n.left) &#123;stack.push(n.left)&#125; if(n.right)&#123;stack.push(n.right)&#125; &#125; while(outstack.length)&#123; const m&#x3D;outstack.pop() console.log(m.val) &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2020-11-05T14:17:18.419Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[],"tags":[],"keywords":[]},{"title":"执行上下文于调用栈","slug":"执行上下文","date":"2020-11-02T04:20:43.000Z","updated":"2020-12-16T08:57:43.124Z","comments":true,"path":"2020/11/02/执行上下文/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"执行上下文所谓的执行上下文其实就是代码所处的环境分类全局执行上下文函数执行上下文eval执行上下文–我不用调用栈每当执行上下文创建一个就将起推入调用栈中，然后当函数执行完后，对应的函数执行上下文才会出栈，从而让出资源空间 从这里开始，就可以知道作用域的本质了，其实就是当前所处的执行上下文了 那为什么作用域外部无法访问到另一个作用域的内部 原理其实是因为当外部执行上下文想要去访问函数执行上下文里的变量的时候，它出栈了自然是无法访问了 那为什么内部作用域又能去访问外部作用域 其实这是因为zhi’x 全局执行上下文执行过程 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 执行阶段 js引擎开始一行行执行代码，并开始给变量赋值 由此引出了变量提升的本质 其实是因为js的执行上下文的创建阶段和赋值阶段并不同步所造成的 创建阶段给变量开辟空间然后赋了初值undefined 之后赋值的时候由于在访问的变量的时候，要去赋值的代码还未执行，所以依然是undefined 函数执行上下文（调用时才会推入调用栈中） 创建阶段 首先明确一点这个是在函数调用的时候才生成的 创建this 将其指向调用者 无人调用就指向window 也就是说，普通函数之所以this指向window其实是这里指定的 创建arguements 这里面包含着函数所有的参数 创建作用域链 是这样你想一想，你在全局执行上下文已经有了全局对象了，那函数执行上下文自然不用再去建立了 执行阶段 一行行执行函数内部的代码 那为什么一定要有他，存在的意义是什么，其实从网络体系分层的思想可以看出来，目的就是在解耦，降低代码执行的复杂度","categories":[],"tags":[],"keywords":[]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2020-11-02T15:28:25.508Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"BFC","slug":"BFC","date":"2020-10-01T13:48:45.000Z","updated":"2020-11-02T15:28:25.524Z","comments":true,"path":"2020/10/01/BFC/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/01/BFC/","excerpt":"","text":"为什么设置over-flow:hidden,可以清除浮动 要了解bfc块，内部的块级元素会垂直摆放，同属于一个bfc块会发生margin重叠，那么消除这样的bug就可以给其中一个元素在套一个容器让他成为令一个新的bfc块（还要设置一个over-flow:hidden). 给父元素加了一个over-flow:hidden就是为了使用bfc块的特性：在计算bfc块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用BFC消除margin重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2020-11-02T15:28:25.492Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[],"tags":[],"keywords":[]},{"title":"复盘背包问题","slug":"复盘背包问题","date":"2020-02-12T14:20:00.000Z","updated":"2021-02-24T12:58:52.419Z","comments":true,"path":"2020/02/12/复盘背包问题/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/12/%E5%A4%8D%E7%9B%98%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"背包问题 首先第一点什么是背包问题，就是说这个问题就是说这个","categories":[],"tags":[],"keywords":[]},{"title":"中间件","slug":"中间件","date":"2020-02-01T14:22:00.000Z","updated":"2021-02-19T07:57:58.952Z","comments":true,"path":"2020/02/01/中间件/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"express中间件原理分析 先来分析一下怎么用的","categories":[],"tags":[],"keywords":[]},{"title":"cookie redis session","slug":"cookie session redis","date":"2020-01-20T04:20:43.000Z","updated":"2021-02-18T14:08:38.601Z","comments":true,"path":"2020/01/20/cookie session redis/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/20/cookie%20session%20redis/","excerpt":"","text":"思路 首先明确一下有了cookie，为何又要又session,那么redis又是解决了什么样的问题 cookie最大的弊端就是用户信息会暴露在客户端中，更多的是安全性问题，所以引出了session技术。 首先第一次登录的时候，服务器向客户端返回一个随机id号码，时会将这个id号码赋值给req.sessionid，并且将用户信息先存到session中，然后以键值对的形式存放到redis中（sessionid,session) 同时客户端下次请求的时候会带上这个sesssionid号，通过get 在redis中返回对应的session信息，这里就存储着用户的信息，自然也不必用户再去重复登录了，同时也基于此，进行了权限认证的问题。","categories":[],"tags":[],"keywords":[]},{"title":"V8引擎基础总结","slug":"V8引擎","date":"2020-01-01T14:22:00.000Z","updated":"2021-02-24T13:18:06.065Z","comments":true,"path":"2020/01/01/V8引擎/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/01/V8%E5%BC%95%E6%93%8E/","excerpt":"","text":"V8引擎如何来执行一段js代码首先你想想，v8想要来执行一段代码，首先你得有一个初始环境吧，基础环境 全局执行上下文 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 全局作用域 里面有全局变量，全局函数 想来存储对象，不得需要创建存储的空间吗/堆 —栈 事件循环系统 web api 有了基础环境就可以来执行代码了 为了能够让v8引擎识别代码，需要将其结构化 AST 转为/字节码中间代码 交给解释器来执行 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 作用域 监控器–如果监控发现解释器在重复执行某段代码 会将其转为热点代码 交给编译器编译为二进制机器码–在进行优化 下次再执行解释器优先解释执行优化过后的二进制机器码代码 闭包V8执行代码过程 编译 将代码转为中间代码 AST树 特点 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 执行阶段 三大特性 允许函数嵌套函数 允许内部函数访问外部函数的变量（依赖作用域链） 正是由于这个特性，在惰性解析阶段 ,由于并不清楚内部函数是否引用了外部函数的变量，从而导致这个变量无法被回收 为了解决这个问题，预解析器 检查函数的内部是否有错 判断函数内部是否存在引用了自由变量 会将这个变量复制到堆中，这样，即便父函数执行完毕后，变量被销毁，子函数依然可以在堆中找到我所引用的变量 函数可以作为返回值（函数是一等公民）所以可以实现类似基本数据类型的事情 编译流水线·宿主环境 浏览器为v8执行javascript提供了必要条件 node.js也是v8的宿主环境 存储空间 栈空间 存储函数的/这个是不是所谓的函数调用栈 也就是说每调用一次函数 就将其推入栈中，由于栈的空间是连续的，并且是有限的，所以随着不断的递归调用，栈会溢出 v8引擎首先会将全局执行上下文推入栈中，之后调用函数会再次将函数执行上下文推入栈中 堆空间 基础数据类型 那现在有了存储空间的创建，还有全局执行上下文，和函数上下文还缺点什么，还缺宿主环境提供的主线程 原因在于v8执行代码其实是依赖于宿主环境提供的主线程 主线程会循环的调用，消息队列里的任务 垃圾回收机制当v8引擎判断某个变量不再需要的时候会进行处理分类 为什么要分类 为了针对不同对象的生存周期，来灵活处理 堆？为什么不是栈 新生代 内存空间很快会被回收 老生代 能到老说明什么，生存周期久 主垃圾回收器 算法 标记–清除算法 标记–整理 步骤 V8引擎会来判断对象是否可抵达 可抵达 可以被清除 不可抵达 不可以被清除 但在清除之前，将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个久是让内存空间尽可能的连续 最后才去清除所有可抵达的对象 副垃圾回收器 堆里 新生代 存储空间 空闲区域 老生代 步骤 当新生代的对象里的存储空间，存储数据，并且要被删除之前会复制存活的活动对象，给空闲区，并存到连续的空间内，之后存储空间和空闲区域，进行调换 如何解决异步回调的问题promisefetchgenerater 为什么有了promise 还要有generater 主要是因为处理逻辑过于复杂的话，会充斥着大量的then()方法，依然不便理解 想来利用同步的方式来书写异步的代码 函数暂停执行 遇到异步执行任务，暂停整个函数的执行 函数恢复执行 当得到了某个异步任务请求的数据，后再恢复函数的执行 弊端就是依然需要，co函数，繁琐 async/await 用同步的形式，书写异步的代码 底层逻辑：微任务和协程应用 async 异步执行并隐式返回promsie 先来通俗的理解，当用了async后，遇到await 会等await后的函数，也就是说async 函数，会暂停执行，在合适的时机来返回 那么问题来了–何时恢复其执行 await等待的类型 普通表达式 V8引擎会自动将其包装为已经成功的promise对象 promise 会暂停async 声明的函数，然后等待promsie对象的状态转变为fullfiled/rejected才会恢复函数执行 UI线程消息队列 当通过鼠标，键盘等所触发的事件，会推入到ui线程里 由主线程来不断取出，再执行那怎么来理解settimeout里回调函数的执行 就是ui线程遇到settimeout会将里面的回调，包装为事件，推入宏任务队列里面 宏/微任务队列 宏任务 微任务 主线程 调用栈 先推入全局执行上下文 每调用一个函数就将其推入栈中 每执行完一个函数之后，就将其出栈 这里如果遇到没有终止条件的递归函数，由于调用栈空间有限里面会存在过多的函数执行上下文导致栈溢出 消息队列 来理解一下为什么会有微任务，它的出现解决了什么问题 主要解决了宏任务执行时机不可控的问题 回调函数同步回调 就是在以（回调函数为参数的函数）执行函数内部，去执行回调函数的 异步回调 就是在在其它位置/其它时间点来调用回调函数，settimeout 是将其内部的回调函数，封装为一个宏任务，由主线程某一时刻，来取出并执行的","categories":[],"tags":[],"keywords":[]}]}