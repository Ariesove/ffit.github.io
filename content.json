{"meta":{"title":"Hexo","subtitle":"","description":"","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[],"posts":[{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2020-11-05T14:17:18.419Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[],"tags":[],"keywords":[]},{"title":"异步","slug":"异步","date":"2020-10-10T13:20:47.000Z","updated":"2020-11-02T15:28:25.461Z","comments":true,"path":"2020/10/10/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/10/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步先明确一下什么是回调函数就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数那它和异步有什么关系 回调函数能够获得异步任务的结果 那么为什么要有异步有些异步任务实在是太耗费时间了，如果不引入同步机制的化会浪费不必要的时间它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 哪些属于异步任务 settimeout() dom事件 AJAX/AXIOS请求 setinterval() 异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱？？ 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending 初始化的状态 resolved 就是成功执行的状态 resolved会触发then方法 而Then方法所返回的状态为resolved reject 异步任务出错/或是抛出异常的时候 会去触发catch方法 catch所返回的状态还是为resolved 谨记一点就是 promise的状态的改变是不可逆的 一旦成为resolved状态 或是rejected状态 后续改变promise状态的resolve()/reject( )全部失效 有哪些方法 resolve() 这里牢记promise.resolve()所返回的是一个成功状态的promise对象 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务","categories":[],"tags":[],"keywords":[]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2020-11-02T15:28:25.508Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"BFC","slug":"BFC","date":"2020-10-01T13:48:45.000Z","updated":"2020-11-02T15:28:25.524Z","comments":true,"path":"2020/10/01/BFC/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/01/BFC/","excerpt":"","text":"为什么设置over-flow:hidden,可以清除浮动 要了解bfc块，内部的块级元素会垂直摆放，同属于一个bfc块会发生margin重叠，那么消除这样的bug就可以给其中一个元素在套一个容器让他成为令一个新的bfc块（还要设置一个over-flow:hidden). 给父元素加了一个over-flow:hidden就是为了使用bfc块的特性：在计算bfc块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用BFC消除margin重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2020-11-02T15:28:25.492Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[],"tags":[],"keywords":[]}]}