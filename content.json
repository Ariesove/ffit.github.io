{"meta":{"title":"Hexo","subtitle":"","description":"简单点","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[{"title":"categories","date":"2021-03-04T15:13:22.000Z","updated":"2021-03-04T15:13:22.763Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/HEXOS/hexos/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"https优化","slug":"https性能优化","date":"2021-02-15T01:20:47.000Z","updated":"2021-03-15T03:45:17.470Z","comments":true,"path":"2021/02/15/https性能优化/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/15/https%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"https优化 由于硬件升级成本高，并且前端也做不了，主要考虑协议上的优化。 首先尽量选取tls1.3因为其往返时间，减半将hello信息和椭圆曲线及公钥也一并进行了交换，所以快，如果只能1.2就用ECDH椭圆曲线算法，最好用x25519曲线。 此处联想身份验证时所发的证书，肯定越小越好，所以用椭圆曲线，比RSA更好，因为其位数更小 sessionID 首先就是由于每次建立https连接都要重新进行握手然后算主密钥，太繁琐，所以每次tls握手结束后将主密钥存储到内存里，双方各生成与之对应的sessionid，相当于一个键值对，所以的话就是说下次握手时将id带上，然后服务器在内存中找到主密钥，就可以直接进行加密信息了。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"js 栈和堆","slug":"js栈和堆","date":"2021-02-11T01:20:47.000Z","updated":"2021-03-15T03:38:58.758Z","comments":true,"path":"2021/02/11/js栈和堆/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/11/js%E6%A0%88%E5%92%8C%E5%A0%86/","excerpt":"","text":"js 栈和堆个人理解就是简单数据类型，都放在栈中，复杂数据类型对象的地址存放在栈中，在堆中存储这个对象的值。 如果是 let a=1 a=’scx’ 对于简单数据类型的仅重新赋值，不会去开辟空间。 谁块：栈块，因为栈先进后出的数据结构更加的简单，栈是编译时系统自动分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。并且每次访问用类型数据都是先访问栈里的对象的引用，然后再去找堆里的对象。所以步骤多了，慢。 js 数组为什么不需要去分配固定的空间 js 里的数组是一个特殊的对象，为什么数组长度可变，为什么这个数组可以存储多个类型数据，因为是一个对象。快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，慢数组是用类似哈希表的形式创建的。 如果 v8 引擎发现数组内部出现了大量空洞，就是比如 arr=[1,3] arr[1222]=1 ,那就转为慢数组，因为不需要去申请大量连续空间，但是是以一种 hash 表来展示的。 慢转快；就是这个，js 数组的空洞少的时候就会去转换，这就是为什么 js 不需要分配固定长度的本质原因。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"进程和线程总结","slug":"进程线程总结","date":"2021-02-01T03:20:47.000Z","updated":"2021-03-15T03:42:08.135Z","comments":true,"path":"2021/02/01/进程线程总结/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/01/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"进程和线程的区别思路： 首先所谓的进程就是，资源调度的基本单位 线程就是依附于**进程的一个独立**的执行单元。 它俩的区别就是，一个进程可以有多个线程，线程依附于进程进程有独立的单元，也就是说一个进程的崩溃，不会影响其它进程，而一个线程挂掉，代表着整个进程崩溃，进程之间的内存难共享，而线程之间的数据是可共享的， 易理解思路： 线程在进程下行进（ 一个进程可以包含多个线程 不同进程间数据很难共享 同一进程下不同线程间数据很易共享 进程要比线程消耗更多的计算机资源 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉 进程可以拓展到多机，进程最多适合多核 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 进程使用的内存地址可以限定使用量 进程/线程之间如何来通信 进程之间通过管道（有这个有名字的无名字的管道）匿名管道，具名管道，消息队列，然后还有这个，信号量（发送消息）套接字，可用于不同设备之间的。 线程之间就是通过锁机制，读写锁，互斥锁，信号量机制，用来同步线程之间的消息的。 线程之间哪些资源共享，哪些不共享1 .标识线程的线程 ID，栈空间是私有的的，堆空间是共享的，全局变量是共享的。 死锁 概念： 多个进程，竞争资源导致的阻塞现象 条件： 1：互斥条件：就是资源非共享，想获取这个资源就得等这个资源被释放。2：不可剥夺：就是你不能随意占据已经被使用的资源，3：请求和保持：吃着碗里的看着锅里的，就是自己占着资源，但还在申请资源，同时不去释放资源。4：环路等待条件：（进程资源形成一条循环链）存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求。 怎么避免就是：银行家算法，判断当前系统是否存在安全序列，如果有那么就同意进程请求资源，不存在安全序列，就阻塞这个请求因为有可能发送死锁.","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"cookie redis session","slug":"cookie session redis","date":"2021-01-20T04:20:43.000Z","updated":"2021-03-15T03:35:19.318Z","comments":true,"path":"2021/01/20/cookie session redis/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/20/cookie%20session%20redis/","excerpt":"","text":"session 怎么实现登录的 cookie 如何来实现登录校验：就是每次用户登录过后服务端为用户设置一个 cookie：并且是一个随机数，不是真实的用户信息。这个 cookie 要设置过期时间以及设置这个 http:only 字段 用户的 cookie 值所对应的真实信息，都存储在服务器端的 session 里， 就是登录后下次请求，带上 cookie 做身份验证，服务器在 session 中找对应关系，能找到对应的信息，就通过并返回数据。 node.js 是多进程，进程之间的内存无法共享，所以需要用到这个 Redis,就是将所有 session，存储到 Redis 中。 考点：那么 session 有什么问题 内存存储到 node.js 进程里，那么内存有限2：由于真实的环境下是用多个进程所以，你第一次存第一个进程，第二次登录想找自己登录所对应的用户信息，就找不到，进程之间无法共享内存，每个进程都有自己独有的内存区域，但其内存又是有限的3：node.js 是多进程的，因为能够提升运行的效率Redis 就是来解决如何能够进程之间共享内存的问题：内存数据库是什么就是一种缓存上的一个数据库访问速度快，但内存小成本高Web server （类似于 node.js 的进程服务) 之前 session 是存在这上面的，然后之后二的话就是说。 考点：存到 Redis 里这样不会占用 node.js 的一个内存空间，现在统一的把 session 放到了 Redis 中，这样就可以是实现了，内存共享。 那为什么用 Redis 存储 session，而不是用 MySQL，因为要频繁访问，性能要求高（内存更块），数据量更大一些session，","categories":[{"name":"后端","slug":"后端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"V8引擎基础总结","slug":"V8引擎","date":"2021-01-01T14:22:00.000Z","updated":"2021-03-04T15:33:50.599Z","comments":true,"path":"2021/01/01/V8引擎/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/01/V8%E5%BC%95%E6%93%8E/","excerpt":"","text":"V8引擎如何来执行一段js代码首先你想想，v8想要来执行一段代码，首先你得有一个初始环境吧，基础环境 全局执行上下文 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 全局作用域 里面有全局变量，全局函数 想来存储对象，不得需要创建存储的空间吗/堆 —栈 事件循环系统 web api 有了基础环境就可以来执行代码了 为了能够让v8引擎识别代码，需要将其结构化 AST 转为/字节码中间代码 交给解释器来执行 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 作用域 监控器–如果监控发现解释器在重复执行某段代码 会将其转为热点代码 交给编译器编译为二进制机器码–在进行优化 下次再执行解释器优先解释执行优化过后的二进制机器码代码 闭包V8执行代码过程 编译 将代码转为中间代码 AST树 特点 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 执行阶段 三大特性 允许函数嵌套函数 允许内部函数访问外部函数的变量（依赖作用域链） 正是由于这个特性，在惰性解析阶段 ,由于并不清楚内部函数是否引用了外部函数的变量，从而导致这个变量无法被回收 为了解决这个问题，预解析器 检查函数的内部是否有错 判断函数内部是否存在引用了自由变量 会将这个变量复制到堆中，这样，即便父函数执行完毕后，变量被销毁，子函数依然可以在堆中找到我所引用的变量 函数可以作为返回值（函数是一等公民）所以可以实现类似基本数据类型的事情 编译流水线·宿主环境 浏览器为v8执行javascript提供了必要条件 node.js也是v8的宿主环境 存储空间 栈空间 存储函数的/这个是不是所谓的函数调用栈 也就是说每调用一次函数 就将其推入栈中，由于栈的空间是连续的，并且是有限的，所以随着不断的递归调用，栈会溢出 v8引擎首先会将全局执行上下文推入栈中，之后调用函数会再次将函数执行上下文推入栈中 堆空间 基础数据类型 那现在有了存储空间的创建，还有全局执行上下文，和函数上下文还缺点什么，还缺宿主环境提供的主线程 原因在于v8执行代码其实是依赖于宿主环境提供的主线程 主线程会循环的调用，消息队列里的任务 垃圾回收机制当v8引擎判断某个变量不再需要的时候会进行处理分类 为什么要分类 为了针对不同对象的生存周期，来灵活处理 堆？为什么不是栈 新生代 内存空间很快会被回收 老生代 能到老说明什么，生存周期久 主垃圾回收器 算法 标记–清除算法 标记–整理 步骤 V8引擎会来判断对象是否可抵达 可抵达 可以被清除 不可抵达 不可以被清除 但在清除之前，将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个久是让内存空间尽可能的连续 最后才去清除所有可抵达的对象 副垃圾回收器 堆里 新生代 存储空间 空闲区域 老生代 步骤 当新生代的对象里的存储空间，存储数据，并且要被删除之前会复制存活的活动对象，给空闲区，并存到连续的空间内，之后存储空间和空闲区域，进行调换 如何解决异步回调的问题promisefetchgenerater 为什么有了promise 还要有generater 主要是因为处理逻辑过于复杂的话，会充斥着大量的then()方法，依然不便理解 想来利用同步的方式来书写异步的代码 函数暂停执行 遇到异步执行任务，暂停整个函数的执行 函数恢复执行 当得到了某个异步任务请求的数据，后再恢复函数的执行 弊端就是依然需要，co函数，繁琐 async/await 用同步的形式，书写异步的代码 底层逻辑：微任务和协程应用 async 异步执行并隐式返回promsie 先来通俗的理解，当用了async后，遇到await 会等await后的函数，也就是说async 函数，会暂停执行，在合适的时机来返回 那么问题来了–何时恢复其执行 await等待的类型 普通表达式 V8引擎会自动将其包装为已经成功的promise对象 promise 会暂停async 声明的函数，然后等待promsie对象的状态转变为fullfiled/rejected才会恢复函数执行 UI线程消息队列 当通过鼠标，键盘等所触发的事件，会推入到ui线程里 由主线程来不断取出，再执行那怎么来理解settimeout里回调函数的执行 就是ui线程遇到settimeout会将里面的回调，包装为事件，推入宏任务队列里面 宏/微任务队列 宏任务 微任务 主线程 调用栈 先推入全局执行上下文 每调用一个函数就将其推入栈中 每执行完一个函数之后，就将其出栈 这里如果遇到没有终止条件的递归函数，由于调用栈空间有限里面会存在过多的函数执行上下文导致栈溢出 消息队列 来理解一下为什么会有微任务，它的出现解决了什么问题 主要解决了宏任务执行时机不可控的问题 回调函数同步回调 就是在以（回调函数为参数的函数）执行函数内部，去执行回调函数的 异步回调 就是在在其它位置/其它时间点来调用回调函数，settimeout 是将其内部的回调函数，封装为一个宏任务，由主线程某一时刻，来取出并执行的","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"异步理解","slug":"异步","date":"2020-12-29T12:22:00.000Z","updated":"2021-03-04T15:32:51.561Z","comments":true,"path":"2020/12/29/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/29/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending new/创建 一个promise后的状态 fulfilled 调用promise.resolve()的方法后 rejected 异步任务出错/或是抛出异常后//但是如果仅仅是return 了一个错误对象，也是不行的 调用promise.reject() 不同状态所触发的方法 then() 首先当promise对象为fullfiled时会触发 里面只能接收一个函数，其它类型一律无视 并且会返回一个新的fullfiled(一般情况下，如果throw了一个错误)promise对象 这也解答了自己一个疑惑就是说，为什么then可以链式来调用，不是状态只能变一次吗，其实是因为又新建了一个新的promise对象 catch() 当状态为rejected时触发 返回了一个具有fullfiled状态的promise对象 finally 无论什么状态，最终都会执行的函数 谨记一点就是 promise的状态的改变是不可逆的 一旦成为fullfilled状态，或是rejected状态 即便是同状态的改变也不可以 核心 状态仅能改变一次 再具体一点就是说，一旦状态变了，后续,resolve(),reject()方法全部失效 有哪些方法 resolve(value) 成功 Subtopic value是一个带有then()方法的对象 由then()方法所返回状态来决定 从这可以看出来，then()方法返回的并不一定是成功的状态 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务 它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 那么为什么要有异步有些网络请求实在是太耗费时间了，如果不引入异步机制的话会浪费时间，用同步的话，只要第一个任务没完成后面的任务全部阻塞了哪些属于异步任务settimeout()dom事件AJAX/AXIOS请求setinterval()回调函数 先明确一下什么是回调函数 就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数 那它和异步有什么关系 回调函数能够获得异步任务的结果","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTPS基础","slug":"HTTPS","date":"2020-12-25T14:22:00.000Z","updated":"2021-03-04T15:33:43.896Z","comments":true,"path":"2020/12/25/HTTPS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/25/HTTPS/","excerpt":"","text":"HTTPS复盘HTTPS对称加密 其实就是说用同一个经过交换的公钥来加密信息 弊端：交换过程容易被中间人所攻击 非对称加密 其实就是用公钥加密，私钥解密 服务器（公钥a-私钥a)先将公钥a发给客户端，客户端拿到公钥a后加密自己生成一个随机数，然后再发给服务器，服务器再拿私钥a来解密公钥a所加密的随机数 之后再去用这个随机数充当之后对称加密的公钥 TLS握手阶段/ECDHE算法 一阶段 客户端 client hello 支持的TLS协议版本号 支持的密码套件 Client Random 服务器 server random 确认TLS协议版本号 确认选取某个密码套件 Server Random 二阶段 此时服务器为了能够验证自己的身份,向客户端发送证书（里面包含着服务器给客户端所发的公钥） 以ECDHE举例：之后服务器还会发给客户端一个Server params 用于密钥交换算法 密钥交换阶段 客户端 此时收到证书，先验签证明是如期的通信方后，取出证书里的公钥，同时生成一个Client Params,发给服务器，此时双方基于ECDHE算法（client params server params )生成Pre-master 对称加密的过程 客户端 此时拥有三个随机数 client random server random pre-master 服务器 同理也生成了一个Master Secret 之后双方拿这个Master随机数来加密finished 信息代表握手结束，之后就拿这个Master来当对称密钥，来进行之后的对称加密 默认端口443不可否认性TLS密钥交换算法签名算法对称加密算法摘要算法身份验证子主题完整性由于黑客可能窃取足够多的密文，并改造，重组再发给服务器，此时如果无法保证信息的完整性，服务器只能全盘接收依据其响应反推密文，所以此时要来保证信息的完整性摘要算法 单向将密文压缩为独一无二的摘要 SHA-2 常用算法 特点 单向性 无法由摘要反推密文 雪崩效应 微小的改变都会造成极大的改变，避免黑客篡改信息 具体应用就是说 此时客户端发送用会话密钥加密的消息以及对应的摘要 服务器接收并用会话密钥解密后，拿到信息，自己再用SHA-2算法生成摘要来比对对方的摘要，无变动说明没有改动 机密性对称加密 用同一个公钥加密和解密 常用算法 chacha20 AES 分组模式 将密钥转化为密文 密钥加密明文转换为密文 非对称加密 通俗来讲网站保管私钥，网上分发公钥 公钥加密，私钥解密 单向性 解决了对称加密中密钥交换的安全性 常用算法 RSA 基于整数分解的数学难题 ECC 基于椭圆曲线离散对数 ECDHE子算法 用于密钥交换 弊端就是由于基于各种数学难题，所以运算速度极慢 所以HTTPS采用混合加密","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"tcp简要总结","slug":"TCP","date":"2020-12-23T14:12:00.000Z","updated":"2021-03-04T15:33:47.716Z","comments":true,"path":"2020/12/23/TCP/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/23/TCP/","excerpt":"","text":"TCP这一次首先复习一下TCP重传机制为什么TCP会重传呢 TCP建立连接的过程如果这个过程如果有丢包那么就会触发重传机制 超时重传 就是TCP内部有一个机制会设定一个时间（时延）这个时间大概略大于，tcp报文往返时间，这个时间的设置不能太短，如果太短那报文还没来的及发回来就误认为包丢了，导致重传，但是也不能设置的太长，这个会造成网络资源浪费（为什么会造成资源浪费我来解释一下：就是说如果时间设置太长了，此时真的发生丢包了，那客户端等很久之后才重发，那不是很浪费网路资源嘛对吧； 快速重传 为什么已经有了超时重传：还要有快速重传 其实是这样，就是说，由于超时重传，是要等一段时间才重传，其实效率并不是很高，所以网络设计们采取了快速重传机制这样效率更高 什么时候会触发快速重传机制，比如此时发送方发送了三个数据包（1，2，3），其中2没有发送出去，接收方只发出基于第一个数据包的确认号，并且重复了三次（不包含第一次的确认，再此基础上，再来三次确认）这个确认号，就是告诉发送方，2这个数据包丢失了，需要对方重新发送，于是触发了发送方的快速重传机制，发送方会重新传送2这个丢失数据包 特点 接受方会重复发送丢失包的确认号 缺点 这里存在一个问题就是，发送方是依据所收到的确认号，来确认接受方是否收到了数据，但是此时发送方只接受到了丢失包的确认号，它也不知道之后的数据包到底发送成功没；————于是Sack就是来解决这个问题的 SACK 这里我通俗来讲一下，就是说为了能够让对方知道自己到底具体传哪些丢失的数据包，每次服务器发来的确认号，还会带上服务器已收到的最大 连续的包的序列号 滑动窗口为什么要有滑动窗口 为了提升网络传输效率 原因在于tcp为了能够实现可靠信息的传输：为每一个数据包都进行确认，那么这就导致了，数据包往返时间越长，网路通信效率就会大幅度的降低（不是很理解网络吞吐量），所以才引用到了窗口 怎么做的：就是为tcp报文设立一个滑动窗口，这个滑动窗口的大小由服务器决定/并且，是无需等待对方的确认，而可以继续发送的数据包 发送窗口 已收到确认的序列号 已经发送但未收到确认的序列号（这个窗口的尺寸大小是服务器能接受的） 还有一段未发送，但在接收方能力范围内的数据段（又称可用窗口的大小）（未发送但是可发送的包） 超出了服务器所能接受的序列号 接收方滑动窗口 已收到数据，并且已经确认的数据段 未收到数据但是可以接受的窗口大小 未收到数据但是无法确认的数据段 那有一个问题就是如果中途其中一个确认号丢失了，怎么办 滑动窗口中的序列号是有序的，这也就意味着确认号也是有序的，只要缺失的那个序列号的确认号之后的确认号得到了确认，那么就是一种累计确认，只要某个确认号确认后默认之前的所有序列号都得到了确认（这里我对于序列号不是很理解） 滑动窗口是怎么个滑动法 就是服务器发来确认号后，发送方的滑动窗口相应的就会滑动和确认号序列相同的距离，意味着可用窗口增加了 补充：滑动窗口大小的含义：指的是发送方不必等待对方的确认，可以发送的最大报文段 流量控制就是来控制发送方发送数据的速率，防止超出接收方处理接收数据的能力依赖于滑动窗口 意思就是通过告知发送方自己的接收窗口大小rwnd来，控制发送方的数据–从而实现了流量控制 那所谓的窗口是什么：就是接收方最大所能处理的数据量窗口关闭 主要就是在接收方发送给发送方自己最新的接收窗口大小的时候，发生了丢失–tcp的可靠传输没有对窗口大小的消息产生作用 双方都在等待对方 拥塞控制拥塞控制主要是避免发送方不断的发送数据而导致网络拥塞那为了避免拥塞，需要客户端维护一个拥塞窗口（CWND）ssthresh//阈值有哪些算法 慢开始 就是一开始每当收到一个ack，其cwnd加一个，第二轮收到2个，cwnd就为2，第三轮次收到4个ack，cwnd为4,这样呈现了指数增加 拥塞避免 但是随着客户端发送数据数量的增加 一定会到达阈值 进入拥塞避免后每收到一个确认，cwnd只加1/cwnd，比如当前收到了8个确认，一个加1/8,这次拥塞窗口仅加了一次，之后就是线性增长了 拥塞发生 你即便是再怎么避免，还是会导致网络拥塞 超时重传 进入拥塞避免算法 但是这里有一个问题就是说：每次一进入拥塞避免，拥塞窗口，直接就初始化为1 就算网络不拥堵，但是会卡顿，因为所能发送的数据包骤减 此时客户端认为其实网络情况也没有那么糟糕 ssthresh=cwnd/2 初始化cwnd=1 快重传 cwnd/2 sshred=cwnd/2 快恢复 触发快重传后，紧接着执行 cwnd=ssthred+3(ack报文） 很明显拥塞窗口已经大于阈值了：之后再次进入线性拥塞避免算法","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"es6基础","slug":"es6","date":"2020-12-15T14:20:00.000Z","updated":"2021-03-04T15:33:39.344Z","comments":true,"path":"2020/12/15/es6/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/15/es6/","excerpt":"","text":"es6promise/generator/async/await箭头函数是什么 function的一种简化 何时用 简化函数，凡是用到函数的时候就可以用 怎么用 无参数 &lt;ol&gt;&lt;li&gt;（）=&gt;{&nbsp; &nbsp;}&lt;br&gt;&lt;/li&gt;&lt;/ol&gt; 有多个参数时 const&nbsp; fun=(a,b,c)=&gt;{&nbsp; return 函数体} 注意要得到函数返回值别把return忘记 正则表达式什么是 限制用户所输入的信息，的表达式 什么时候用 表单验证 用户名输入的时候 子主题 对于密码验证的时候 怎么用 起止符 ^ 开始符号 &amp;结束符 多选一符号 [ ] 组合符号 ^[^A-Z0-9${2,3} ] 后面花括号代表的是从前面选2-3个元素； 作用域块级作用域 const 这个和let的最大的区别就是，const不可以先只声明 为什么 const所定义的是一个定值，如果你只声明不赋值，如何做到是一个定值，感觉有点勉强 let Subtopic 它首先解决了var变量提升的问题 它怎么解决这个问题的，将全局执行上下文的创建阶段和执行阶段时机同步了所以不会再出现变量提升的问题 它还解决了，var没有作用域的问题 由块级作用域，引发了一个问题就是暂时性死区 什么时候会引发暂时性死区 条件 如果在一个块级作用域里存在let,那么此时let所处的作用域就会锁死 一旦在变量let声明前,去使用就会为undefined 那我什么时候能用，只有到声明后才可以去使用let/或const所声明的变量 那具体暂时性死区是什么 其实就是let/const声明前的代码区域（在块级作用域中） var 没有块级作用域 那如果没有块级作用域会引发哪些问题 在函数中用var声明的变量，函数外部可以访问，这个就很危险 也会引发变量提升的问题 根据你在声明变量的时候，会出现执行上下文，而创建上下文的创建与执行阶段是不同步的所以造成了变量提升 this指向指向谁 在函数 的内部， . . .实现对对象的深拷贝将数组转为由逗号隔开的序列，同时又可以实现拷贝传递形参时用 如果你并不知道参数有几个的时候？？？ 解构怎么用 需要从一些对象（也可解构多层嵌套对象） 说人话 获取对象里的值 根据对象里的键来获取值 更高端大气怎样将类数组转为真正的数组Array.from(类数组)除过es6以外还有什么方法 Array.prototype.slice( ).call(类数组） 这个不理解 Map（）它解决了什么问题 专门用来存储键值对的 什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构那它有哪些方法 set(键，值） 这个返回的是新的map数据结构，包含有新的设置的键值对 has(键） 返回值为布尔值 目的是为了判断是否存在当前键//这个主要判断是否有对应的键 delete(键) 删除键所对应的键值对 get(键） 这个是在获取键所对应的值 这个在力扣第一题中用到它了 Set()一旦题目中涉及集合立刻想到set 特点就是，一旦题目提到有序，无重复元素，立刻反应Set() Set做了哪些事情 给定一个数组 返回一个没有重复序列的集合 能做到什么 数组去重 首先通过，[…set(arry)] 但是我对于这个有一些问题就是，首先通过…元素是否意思是将set数据结构转为数组，那如果已经是数组了为什么要在加上数组字面量不理解 求交集 怎么做","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"LRU","slug":"LRU缓存机制","date":"2020-12-12T13:48:45.000Z","updated":"2021-03-06T09:08:34.634Z","comments":true,"path":"2020/12/12/LRU缓存机制/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/12/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"思路1. 浏览器 LRU 缓存策略 其实这个就是当输入网址访问时先会去本地缓存查看是否有我想要的数据，如果有直接用本地缓存的数据目的就是降低用户访问的时间 那么这里有一个问题就是，本地缓存总有满的一天，那么删哪些 核心： 删最近最少使用的—可以理解为，正是因为最少被使用，所以才该删 2. vue Keep-alive目的： 用于组件的缓存 具体怎么做的： 就是 keep-alive 有一个 max 属性，一旦缓存的组件数大于了 max 就开始使用 LRU 算法 cache 保存着组件实例，以及所对应的 key 值，然后就是还有一个 keys 数组存储着每一个所缓存组件的 key 值 当用到了某个组件，会先看一下 cache 里面是否有对应组件： 如果有了就将相应的 key 值从 keys 中删除并移动到最后一个元素：其实就是在模拟最近最少算法：头元素肯定是少使用的，放末尾的意思自然是最近就使用的； 当组件数》max 后，删 keys[0] 元素。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"相交链表","slug":"相交链表","date":"2020-12-01T14:22:00.000Z","updated":"2021-03-04T15:32:48.988Z","comments":true,"path":"2020/12/01/相交链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"160. 相交链表。反思 首先这个题的思路就是来联想一下这个相交节点，为什么要用双指针，就是说 a+b+c=b+1+c 也就是说我，都同时开始且路程相同，那么一定会在相交节点，相遇； 因此思路就是只要我能够判断当前的节点是否为空，如果为空了，那就将其接到下一个链表的头节点，如果不为空的话，那就去继续遍历。 自己的不足在于三元表达式不够熟练，就是自己，变量= 条件 ？ a: b ;也就是说只要条件满足执行 a 结果，不满足就执行 b 结果。 12345678910var getIntersectionNode = function(headA, headB) &#123; if(!headA||!headB)&#123;return null&#125; let p1=headA let p2=headB while(p1!==p2)&#123; p1= p1===null? headB:p1.next p2= p2 ===null?headA:p2.next &#125; return p2&#125;; mermaid 注意： 首先这个题只要求节点相同，没有说这个节点的值问题； 其次判断的条件就是这个有一个为空，必然没有相交的节点所以直接，就返回为空就好","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"闭包","slug":"biba","date":"2020-12-01T13:48:45.000Z","updated":"2021-03-05T15:17:35.773Z","comments":true,"path":"2020/12/01/biba/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/biba/","excerpt":"","text":"闭包体系切入点词法作用域 首先我需要从作用域的底层机制说起，首先在 V8 引擎中是有编译阶段的，这里叙述”js 执行代码过程”&gt; V8 引擎如何执行一段代码 编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于混合编译执行，JIT，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率。 这里还有一点就是此时引擎会在当前的作用域去寻找有没有所声明的变量，如果有那就忽略它，这也是为什么，var 可以重复声明的本质原因，如果没有的话就将这个变量存放在当前作用域，赋值阶段。 如何来叙述闭包 切入点词法作用域，那么词法作用域是怎样生成的（此时联想作用域里面有声明了一个变量），那么在编译阶段首先会来判断，当前的作用域有没有这个变量，有了就忽略，继续，没有就直接将变量放置当前作用域内并赋值 undefined. 那你不能光找到它，还得赋值，在当前作用域能找到直接赋值，没找到就不断向外部作用域找形成作用域链。 （谈到作用域本质就联想一个调用栈，里面压入了全局执行上下文，和函数执行上下文））作用域的本质到底是什么，从表层意思来讲，它是一套规则，存放相应变量的规则，从本质上来讲，它是当前所处执行上下文，从这一点可以明白，为什么闭包中，可以从内部访问外部的变量，而外部无法访问内部的变量，全局执行上下文首先会推入调用栈中，之后每当调用一个函数，就会将函数上下文推入栈中，所以即便调用栈中，栈顶执行上下文，执行完毕后出栈，但是内部执行上下文依然可以通过，作用域链来访问，但由于栈顶执行上下文出栈了作用域链也被销毁了，所以无法访问调用栈中上下文的变量。 作用域链也被销毁了，所以无法访问调用栈中上下文的变量。 补充词法作用域 所谓词法作用域本质就是，作用域的形成是在你所定义的位置，而不是你所调用的位置，这一点区别于动态作用域，它是在你所调用的时候，而不是你所定义的位置。 闭包应用。 var a = []; for(let i = 0;i&lt;10;i++)&#123; a[i]=function()&#123; console.log(i) &#125; &#125;; a[2](); 12345678910111213141516171819 在这个块级作用域中，你又定义了一个函数，而这个函数又引用了函数外部的 i 变量，那么这就产生了闭包，也就是说，所有块级作用域中的 i 都不会被销毁，你在这里执行了 10 次循环，那么也就创建了 10 个块级作用域，这十个块级作用域中的变量 i 都会被保存在内存中。 那么当你再次调用该 a[n]() 时，v8 就会拿出闭包中的变量 i，并将其打印出来，因为每个闭包中的 i 值都不同，所以 a[n]() 时，打印出来的值就是 n，这个就非常符合直觉了。 但是如果你将 for 循环中的 i 变量声明改成 var，那么并不会产生块级作用域，那么函数引用的 i 就是全局作用域中的了，由于全局作用域中只有一个，那么在执行 for 循环的时候，i 的值会一直被改变，最后是 10，所以最终你执行 a[n]() 时，无论 n 是多少，打印出来的都是 10. 那么这就是 bug 之源了。2. 循环打印 1，2，3，4，5 和第二种思路比较相似，同样是在 setTimeout 外面再套一层函数，只不过这个函数是一个**立即执行函数** 。利用立即执行函数的入参来缓存每一个循环中的 i 值： &#96;&#96;&#96;js for (var i &#x3D; 0; i &lt; 5; i++) &#123; &#x2F;&#x2F; 这里的 i 被赋值给了立即执行函数作用域内的变量 j (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125; //就是每一次 settimeout 里的 j 对外部立即执行函数里的变量造成了引用，所以，缓存了这个值，因为 v8 不再回收这个被引用的值了，缓存了下来。 闭包的应用模拟私有变量 模拟私有变量：就是之前像是 Java c++ 这些，有 private 私有变量， 就是不是这个类的其它成员，你无法去访问这些私有变量。 在 js 生成一个类是依赖于这个构造函数，但是你实例化一个类会发现，你通过这个类可以访问到这些这个类的属性，但是这个有一个问题就是说，万一我在这个这个构造函数里定义了一些私密数据，那不就可以在这个对象去访问到这个属性了吗。 用立即执行函数，形成一个闭包，返回一个类，然后将私有属性放在函数里，不去通过 this 来赋值，直接进行赋值操作；a=privatedata，这样外部是无法拿到这个私有变量的。 还可以用”symbol:”&gt; 可以用来定义一个绝对唯一的常量，避免命名冲突。 模拟私有变量，就是通过这个定义的属性是私有的，类似于之前通过立即执行函数，来实现的一个私有变量”闭包是如何来实现这个私有变量的”&gt; #### 模拟私有变量 模拟私有变量：就是之前像是 Java c++ 这些，有 private 私有变量， 就是不是这个类的其它成员，你无法去访问这些私有变量。 在 js 生成一个类是依赖于这个构造函数，但是你实例化一个类会发现，你通过这个类可以访问到这些这个类的属性，但是这个有一个问题就是说，万一我在这个这个构造函数里定义了一些私密数据，那不就可以在这个对象去访问到这个属性了吗。 用立即执行函数，形成一个闭包，返回一个类，然后将私有属性放在函数里，不去通过 this 来赋值，直接进行赋值操作；a=privatedata，这样外部是无法拿到这个私有变量的。 还可以用”symbol:”&gt; .来模拟一个私有的变量。 偏函数 bind 的实现 “bind” 思路详解 个人理解 二刷理解： 第一点： 记住执行 bind 会返回一个函数，为什么为了之后的偏函数的应用，s.（a）（b） 返回的函数需要调用它并且来改变它的 this 指向，利用 apply 此时来考虑一下，类数组的问题，就是说，bind 函数里面有许多参数，被 arguements 所收集，你现在想传参数，但是 arguements 是一个类数组，需要转换为真正的数组，利用 array.propotype.slice.call() 此时 bind 还具有偏函数的特性就是 bind 函数第一个括号内部，偏函数就是在第二个括号里的参数,为什么第一个括号里的参数要截取，因为我不需要第一个括号里面的第一个参数，所以要截取，对于第二个括号，只需要将其转化为数组就好，但是所谓偏函数的本质依然要将其两个参数里的东西转换为一个括号里的参数，所以我们需要合并 concat 可以通过 bind 所返回的函数，实例化一个对象 柯里化 多个参数的函数转转化为单个参数的函数。 防抖节流 “防抖&amp;节流”&gt; 思想 节流就是，n 秒内，只触发一次。（timer 无值了，说明第一次的定时任务执行完毕） 防抖就是 n 秒内，触发多次只看最后一次触发，的中间多次触发，会重新计时。（timer 有值得情况会删除之前的定时器） 执行 fn，this 就指向 window 了，要指向触发的 dom 节点，所以要调用 apply 绑定 this。 一定要把这个 timer 放在外面，因为要形成一个闭包，这样在内存中由于闭包，就不会导致这个变量被销毁，这样能够保证多次触发函数所引用的变量是一个 timer. 12345678910111213141516function throter(callback, delay) &#123;//节流 let timer;//闭包应用 return function () &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; callback.apply(this, arguments) &#125;, delay); &#125; &#125;&#125;input.addEventListerener(&#x27;keyup&#x27;, throter(function () &#123; console.log(input.value);&#125;, 1000)) 123456789101112131415161718192021function debance(callback, delay) &#123;//防抖 let timer = null;//闭包的应用 return function () &#123; if (timer) &#123; clearTimeout(timer)//清空定时器操作 &#125; else &#123; timer = setTimeout(() =&gt; &#123; callback.apply(this, arguments) timer = null &#125;, delay); &#125; &#125;&#125;input.addEventListener(&#x27;keyup&#x27;, debance(function () &#123; console.log(input.value);&#125;, 1000)) 。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"V8引擎执行代码","slug":"V8引擎如何执行一段代码","date":"2020-12-01T13:43:45.000Z","updated":"2021-03-04T15:33:56.148Z","comments":true,"path":"2020/12/01/V8引擎如何执行一段代码/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/","excerpt":"","text":"V8 引擎如何执行一段代码编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 全局执行上下文，创建阶段，首先会创建一个全局对象window，创建一个this 然后让它指向这个window，之后为变量和函数分配空间/并且要为变量赋一个undefined，创建作用域链，全局作用域里面有全局变量，全局函数，想来存储对象，不得需要创建存储的空间吗/堆 —栈，事件循环系系统web-api。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于&amp;混合编译执行/解释执行，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"最长子序列","slug":"最长子序列","date":"2020-12-01T12:20:00.000Z","updated":"2021-03-12T08:32:46.194Z","comments":true,"path":"2020/12/01/最长子序列/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 再次复盘 这道题首先看到了最长，最值问题，动态规划正是在解决，最优子结构，就是说一个问题的最优解，是由许多子问题的最优解组合的，并且这个划分子问题的过程就是降低问题复杂度的过程。 这个题首先分析问题，怎么来分解它降低问题的复杂度，就是倒推思考，求f(i) 前i个元素，并包括，i这个元素的求解，第f(i-1) 这个解，只要知道这个解了那就意味着，知道了f(i)的解，那也就是说要递推求解每一个子序列的最优解，最优子结构； 那就来找状态转移方程：f(n)=maxf(i)+1 //前提是i&lt;n 并且nums[i]的值要小于nums[n]这样才能来延长子序列，否则没有延长的必要三刷反思 首先就是说这个题应该是这样就是说，动态规划是这样就是我看到这个题联想双重循环，为什么就是因为这个题我需要去，在遍历每一项，都要从头再次遍历，因为想回过头来看一个问题就是说，只有当前外层遍历到的元素比之前元素大。 思路： 就是每次遍历到每一个元素的时候，内部再去从头遍历，，只有那些值比外层循环遍历到的值小才可以去更新这个dp方程，由于我所定义的dp是第i项的最长递增子序列，只有那些值小的才可在这个基出上加1，并且为什么是 把自身也带上，就是因为当遍历到某一项的时候，是有多个子序列，我需要找最长的那个，才是正真的第I项的最大值，当遍历完毕后，再去更新最大值，只有内层循环完毕，才有必要去，更新最大值，否则你的第i项有可能不是最大值。var lengthOfLIS = function(nums) &#123; if(!nums.length)&#123;return 0&#125; let maxlenght=1 let dp=new Array(nums.length).fill(1) for(let i=1;i&lt;nums.length;i++)&#123; for(let j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; dp[i]=Math.max(dp[i],dp[j]+1) &#125; if(dp[i]&gt;maxlenght)&#123; maxlenght=dp[i] &#125; &#125; &#125; return maxlenght &#125;;//o(n2) o(n)","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"垃圾回收机制","slug":"垃圾回收机制","date":"2020-11-25T14:14:00.000Z","updated":"2021-03-04T15:32:45.564Z","comments":true,"path":"2020/11/25/垃圾回收机制/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制分类为什么要分类—依据 代际假说 一些变量生存周期很短 存放在新生代区域 一些比如window这些存活时间很长的对象 存放在老生代区域 依据生存周期的长短–因地制宜的选取对应的算法来回收 堆/划分的 目的就是为了能根据不同的对象依据对应的垃圾回收机制，进行回收 新生代 存储生存周期短的对象 区域划分依据scanverge算法 对象区域 空闲区域 老生代 专门存储，生存周期长的对象 主垃圾回收器 专门处理老生代里的对象 算法 标记–整理 标记–清除 步骤 先进行标记–对于清除的对象先进行标记 利用标记–整理算法将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个是让内存空间尽可能的连续 再去清除除过这一端的其它垃圾数据 副垃圾回收机制 scanverge算法 专门处理新生代里存储的对象 步骤 利用标记—清除算法清除对象区域里标记的垃圾数据 在标记–清除阶段将活动对象复制到空闲区域，并进行整理 为的就是能够使存储空间尽可能的连续 对象区域和空闲区域调换 首先来明确一下什么样的变量的空间可以被回收依赖可访问性算法通过GCroot对象遍历内部所有对象 window Dom节点 通过GCroot 对象访问变量 可访问到的：活动对象 不可访问：非活动对象 V8引擎清除的将是非活动对象 在早期有一个局限性较大的垃圾回收机制引用计数法 它具体是怎么做的 每产生一个引用就计数加一 什么是引用？ 那它的局限性在哪 它无法识别循环引用的场景，无法使计数为0; eg:A对象的引用指向B，而B的引用又指向A，它们的引用计数都是1，无法成为0, 就会造成内存泄漏； 为0就会被回收 切入点由数据类型说起基本数据类型 symbol number string 布尔类型 复杂数据类型 function 对象","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"翻转链表","slug":"反转链表","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-04T15:32:25.578Z","comments":true,"path":"2020/11/12/反转链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表思路（联想三个指针不断的交换） 如实记录几个月后的复盘结果，就是说自己第一次复盘的时候想到了双指针但是自己想的是一个指向了头，一个指向了尾元素，然后交换，思路完全错误了，错在了哪里 首先对撞指针，更适用于两个元素交换，但是这个题的要求是让反转，而且双指针有一个问题就是说，当两个指针进行交换的时候，下一个节点不就丢了吗 引出了三指针进行交换。 题解思路 核心点三指针，每次只通过 cur.next=pre 来循环翻转 并且每次都需要缓存 next 指针为什么，就是因为你每次都翻转完毕后 cur 的 next 指向会丢失，所以你遍历的时候首先就需要来缓存它。 其次还有一个小细节就是为什么，循环的条件没有 next 不为空，因为为空无所谓，但是删除链表这个题考虑下一个元素主要是是因为，都为空了，就没有去重的必要了，也就是说不必去循环了。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"工具页测试","slug":"工具测试","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-04T15:36:19.498Z","comments":true,"path":"2020/11/12/工具测试/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"盒模型","slug":"迭代法先序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-05T15:36:38.595Z","comments":true,"path":"2020/11/12/迭代法先序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"先来明确一点，为什么一定要用栈，这里我一直遗漏了一点就是 在递归中，再不断调用函数自身的时候，会形成一个调用栈，每调用一次就推入一个函数，执行完毕就去释放？这里不是特别理解理清一下思路（时刻记住其实这个是由递归来改进的） 先设置一个栈结构–为什么为了能够使用栈来模拟调用栈的过程 之后再访问根节点 那怎么来访问根节点，是不是先来入栈，后再来弹出栈，来模拟每调用一次就推入栈，结束后再去弹栈 123456789101112function prorder (root)&#123; const stack=[root]; if(!root) &#123;return&#125;; while(stack.length)&#123; const n=stack.pop();//注意一下这里shift()才是在弹首元素，pop()弹的是尾元素 console.log(n.val); if(n.right) &#123;stack.push(n.right)&#125;; if(n.left) &#123;stack.push(n.left)&#125;; &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"后序遍历","slug":"迭代法后序遍历","date":"2020-11-11T14:20:47.000Z","updated":"2021-03-05T15:36:29.742Z","comments":true,"path":"2020/11/11/迭代法后序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"首先来捋一下思路 后续遍历的顺序是先左子树，再右子树，再根节点 那么从这你思考一下如果我把这个顺序颠倒一下是什么是不是先根节点，再右子树，再左子树，是不是非常的像先序遍历，及就是说把先序遍历的结果再入栈，然后根据栈的先进后出的特性，来得到后序遍历的结果 1234567891011121314151617function lastorder (root) &#123; if(!root)&#123;return&#125; const outstack=[]; const stack =[root]; while(stack.length)&#123; const n=stack.pop(); outstack.push(n) if(n.left) &#123;stack.push(n.left)&#125; if(n.right)&#123;stack.push(n.right)&#125; &#125; while(outstack.length)&#123; const m=outstack.pop() console.log(m.val) &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"GET 和 post 本质区别","slug":"GET和Post本质区别","date":"2020-11-11T01:20:47.000Z","updated":"2021-03-15T03:35:44.602Z","comments":true,"path":"2020/11/11/GET和Post本质区别/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/GET%E5%92%8CPost%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/","excerpt":"","text":"##👱 GET 和 post 本质区别 叙述思路 首先属于 HTTP 协议—–》 引出本质是 TCP 连接——》 引出 tcp 连接次数问题—–&gt; 由次数问题：想到幂等。 其次想到安全幂等，GET 安全幂等，POST 不安全也不幂等。 其次想到想起它们属于 HTTP 协议，也就是说也是基于 TCP 链接的，所以它们的本质都是 TCP 连接。 GET 请求是一个 tcp 报文 :(对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）。) //你请求肯定要有请求头吗，对吧 而 POST 请求是两个 tcp 报文，(浏览器先发送 header，服务器响应 100，浏览器再发送 data，服务器响应 200 ok（返回数据）。) 所谓安全就是不会改变服务器资源，所谓的**幂**想起次幂，也就是说多次的意思 所谓的不安全其实就是会改变，服务器的资源，所谓的不幂等就是，多次操作结果不相同。 💯 100 continue HTTP 100 Continue 信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.// 自己的话就是:👌 因为是 100 分所以目前状态正常，可以继续请求。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2021-03-04T15:32:19.837Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"执行上下文于调用栈","slug":"执行上下文","date":"2020-11-02T04:20:43.000Z","updated":"2021-03-04T15:33:07.791Z","comments":true,"path":"2020/11/02/执行上下文/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"执行上下文所谓的执行上下文其实就是代码所处的环境分类全局执行上下文函数执行上下文eval执行上下文–我不用调用栈每当执行上下文创建一个就将起推入调用栈中，然后当函数执行完后，对应的函数执行上下文才会出栈，从而让出资源空间 从这里开始，就可以知道作用域的本质了，其实就是当前所处的执行上下文了 那为什么作用域外部无法访问到另一个作用域的内部 原理其实是因为当外部执行上下文想要去访问函数执行上下文里的变量的时候，它出栈了自然是无法访问了 那为什么内部作用域又能去访问外部作用域 其实这是因为zhi’x 全局执行上下文执行过程 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 执行阶段 js引擎开始一行行执行代码，并开始给变量赋值 由此引出了变量提升的本质 其实是因为js的执行上下文的创建阶段和赋值阶段并不同步所造成的 创建阶段给变量开辟空间然后赋了初值undefined 之后赋值的时候由于在访问的变量的时候，要去赋值的代码还未执行，所以依然是undefined 函数执行上下文（调用时才会推入调用栈中） 创建阶段 首先明确一点这个是在函数调用的时候才生成的 创建this 将其指向调用者 无人调用就指向window 也就是说，普通函数之所以this指向window其实是这里指定的 创建arguements 这里面包含着函数所有的参数 创建作用域链 是这样你想一想，你在全局执行上下文已经有了全局对象了，那函数执行上下文自然不用再去建立了 执行阶段 一行行执行函数内部的代码 那为什么一定要有他，存在的意义是什么，其实从网络体系分层的思想可以看出来，目的就是在解耦，降低代码执行的复杂度","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2021-03-06T08:33:55.104Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2021-03-04T15:32:39.504Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"垂直水平居中：margin:auto 原理","slug":"垂直水平居中： margin原理","date":"2020-09-11T01:20:47.000Z","updated":"2021-03-13T09:29:33.001Z","comments":true,"path":"2020/09/11/垂直水平居中： margin原理/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/11/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%EF%BC%9A%20margin%E5%8E%9F%E7%90%86/","excerpt":"","text":"margin: auto 原理 第一种可以用 flex 布局 123给父元素，去设置display:flex; justify-content:center//水平居中； align-item:center//垂直居中； ``` css#center { background-color: red; width: 200px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;}1234567891011121314151617181920212223242526274. auto 就是“一样”的意思，如果是左右 auto 的话，意思就是： 这个 DIV 离 左边的距离 跟 右边的距离 是一样的。 margin:0px auto；就是上下的距离是 0px，左右的距离是“一样”。5. **叙述思路**： 垂直方向上，auto 不会自动填充，水平方向上不会去自动填充，所以此时通过，绝对定位并设置上下左右边界，触发流体特性，这样垂直方向上就可以进行自动填充了，从而达到垂直方向上居中的操作。6. 1. 解释下原理: 1 在普通内容流中，margin:auto 的效果等同于 margin-top:0;margin-bottom:0. 2 position:absolute 使绝对定位块跳出了内容流 3 为块区域设置 top: 0; left: 0; bottom: 0; right: ;将给浏览器重新分配一个边界框 ，使元素具有流体特性，此时该元素的所有可用空间，所以 margin 垂直方向上有了可分配的空间。 4 再设置 margin 垂直方向上下为 auto ,即可实现垂直居中。(注意高度得设置) 5. 动画属性：transform:就是 &#96;&#96;&#96;css #center &#123; position:absolute; left:50%; right:50%; transform: translate(-50%,-50%) &#x2F;&#x2F;其实就是因为刚开始，元素左顶点位于中心，所以此时让这个元素相对于自身往左移动50%，再往上移动50%，由于css动画是上负下正，和数学坐标是相反的。 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"vue3项目笔记","slug":"知乎专栏项目笔记","date":"2020-02-20T13:48:45.000Z","updated":"2021-03-05T15:19:45.318Z","comments":true,"path":"2020/02/20/知乎专栏项目笔记/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/20/%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8F%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"7-7vuex 对于 vuex 中的这个通过 actions 去定义获取信息的函数，然后通过在对应的组件中通过这个 commit 来触发这个 mutitions，所以通过这个来实现。 这里的逻辑就是说这个通过在渲染这个一个 id 号下的所有文章的时候，通过，拿到路由里对应的 id 号然后去通过 dispatch 去触发对应的 actions 然后再去在 store 里来修改这样的状态。 亮点通过 async 和 await 来改造 actions 里的异步请求： 项目中遇到了哪些困难 怎么解决的就是在发出异步请求的时候总是返回 500 首先我打开浏览器去发现了自己 url 格式有问题，就是我 dispatch 的时候传递了错误的数据，导致最后拼接 url 的时候出现了错误。 运用 teleport实现组件挂载到另一个节点的时候，我还要去创建一个 div 标签，很不人性化 为什么要在 setup 这个生命周期函数创建就是因为要先在组件渲染完之前创建节点。同时由于你每次渲染一次组件，就创建一个节点，那么就在组件渲染完毕后再去销毁这个节点。 重点：权限管理 token,这里有一个小的问题就是自己错误在于自己在拿到这个 ref 的值得时候没有赋予 val 值。 这里的业务逻辑就是说这个客户这里登录成功后向服务器这里发出一个 post 请求，然后，拿到一个 token，那么这个到底是干什么的。 这里回顾一下，session 怎么来实现登录的，首先在博客项目里，我先通过制定的登录路由，登录，验证通过后，服务器这里创建对应的 session 来将其信息进行保存并存储在这个 Redis 里，之后向客户端这里返回一个 cookie：对应的 sessionid，然后，浏览器存储，当访问需要登录权限的路由时，客户端将 sessionid 通过 cookie 带上，然后通过服务器的验证后就可以返回对应的信息。弊端是什么想一想。 jwt： 一句话，就是信息都存储在客户端 ，而不是存储在服务器里，每次登录成功后，返回一个 token 字段，然后客户端下次访问需要验证的路由时，带上它通过 axios.commn-header，服务器反向验证，通过后就可以直接返回相应的信息了，好处就是减轻服务器压力. 亮点：那么现在我每次刷新，都会重新登录我该怎么来持久化这个状态呢，这里的逻辑就是说这个每次下次登录首页刷新时区判断一下当前未登录，并且，token 值存在，这个值被我存储到了 storage 里，再次添加 token 头字段，进行权限认证通过后，通过访问用户信息的路由，就可以去拿到对应的信息了，并将信息返回并渲染至界面上。 全局组件 message 首先出错这个组件不止是在，某个组件中去用，全局状态下都有可能去用 首先这个全局组件，需要设置一个错误的一个数据结构。一般全局组件的设计思路就是说通过 store 设置全局的状态，并通过这个拦截器，来拦截这些状态，// 这里就是通过失败的回调得到失败的数据，并commit去触发全局错误状态的改变。 这里有一个小问题就是现在当我去点击这个取消错误提示的时候，发现，这里不去显示这个组件了这是为什么，这里对于这个全局组件的理解应该是一个函数，而不是单纯的一个组件，因为这样子我就可以去，传递一些错误的信息提示，以一种全局错误的一种调用就是我需要的时候去调用它，亮点：以函数的形式来创建一个组件，就是先创建一个应用，里面有组件，和 props 的参数，然后通过这个参数来解决这个问题，这里考点: watch 的应用 就是来监听这个全局错误状态的改变，一旦改变了就调用这个组件函数，并传递相应的一个参数。这里遇到的 bug首先就是我发现，点击的时候没有触发相应的事件，于事猜测可能就是这个，事件没有触发因此出现了问题，最后发现这个事件我添加在了外部的容器导致点击，那也就是说，你点击哪个元素就给它去添加事件，你不要去给它添加事件。 文件上传组件：亮点 首先明确一下由于文件上传的格式一般是二进制数据，所以的话需要这个采取 multipart/form-data ，支持二进制数据，难点和亮点就是说通过这个，fjavascript 来模拟这个文件上传。 首先来明确一下这个思路就是，我在点击一个 button 按钮的时候，，想触发这个 input 的上传文件，那么就在点击 button 的时候，给 input 去添加一个 click 事件即可，这里有一个泛型的应用就是可以去给这个 ref 对象去传递一个泛型，这里不是特别的理解， 这个组件的属性必然要有一个 action 就是你往哪里去串，这个 url 所以这个必然是 props 的属性。 设计思路就是首先我需要拿到这个 input file 这个 dom 节点，之后，问题： 拿到这个 dom 节点后，记得要把这个 ref 值往外导出，不然这个 dom 节点上你拿不到，你所定义的这个值，自然也拿不到这个 dom 节点。拿到这个 dom 节点后，当你去触发这个事件的时候，就会拿到这个 files 这个上传的文件，之后，去创建一个 form data 之后再去，将数据 append 到里面，最终在前端通过 post 请求，传递数据，以及设置这个数据类型以这个 mutiply-formdata 的数据格式发送请求。 亮点： 具名插槽的使用，何时用就是在你需要自定义模板的时候，去用，就是我在子组件里去通过定义 slot，并定义这个内容，然后父组件在向子组件传递内容的时候，借助于 template 模板来使用这个，并通过 v-slot 来确定往哪个插槽里去传递内容。 亮点： 如何在父组件中拿到子组件里，的值，，就是如何将子组件里的值，传递到这个父组件里面，，就是结合文档，子组件去定义一个需要向外传递的值，然后父组件在插槽里拿到这个值取渲染你刚才传递的这个照片。 如何来禁止这个属性继承，考点： 如何来让父组件的属性继承到子组件里，通过绑定这个 $attrs,就是在做这个希望让这个上传组件的样式进行自定义，那么我们就需要，在父组件定义属性，比如类名，还有内容。 自定义一个上传组件就是更具不同的状态，结合具名插槽，传递这个不同的状态，所对应的元素。 记录一下小 bug,就是说由于我最终是想去在上传成功的状态去，传递我所定义的成功是展示图片的插槽，但是我在 finnaly 最后又去重新赋值为这个状态为 ready 导致成功的插槽内容始终没有展示。 创建文章逻辑： 我是如何将这个 image 的 id 号和展示文章的 Id 号所对应的就是通过这个， bug: 自己在做的时候发现自己，把 post 的请求发出返回的结果没有注意这个格式，就是自己，因为后端的返回结果其实是把这个数据都放在了 data 里而我是直接跳过了这个 data 直接就继续找到了这个 data。 文章详情页的展示 首先点击按钮可以跳转至详情页，之后的话就是说这个，那就得继续来个路由这个路由出口展示着这个详情页。 分析这个组件设计的思路： 首先我需要这个创建对应的 views 因为是视图的改变，需要创建对应的路由。 在这个 columndetail 上去创建这个链接，跳转至对应的一个界面上去。 在 onmounted 的时候去发送这个单个文章的请求来返回相应的数据。 编辑删除区域 就是你文章详情接口返回了一个 author 数据，你要拿到这个数据里的 id 号和你登录的时候所对应的 id 号进行比对，如果一致的话，那就返回相应的数据，如果不一致的话， 那就不展示对应的编辑删除区域， 编辑模式下的创建文章，必然首先要在组件渲染的时候拿到这个图片进行展示，发出相应的请求进行展示，因为你想编辑模式下，必然是让这个头图，标题，还有文章，都要拿到相应的数据进行展示。 在这个 uploaded 进行数据的一个初始化，就是说这个，这里有一个问题就是说让这个在 props 里的属性进行改变的时候，进行 watch 监听，这样。 Bug:这里记录一下一个 bug，就是说这个我在触发 action 的改变的时候，发现拿不到数据，最后发现自己这个每次没有将自己通过发出 axios 的请求，所返回的数据返回，这就导致了，你通过触发这个 actions 始终拿不到我想要的数据。 对于编辑，删除，跟新的功能，其实通用的思想就是设置 action, mutations 然后，去触发。 对于这个更新文章的思路，就是我们在触发这个对应的 action 的时候是去拿到这个跳转时的 id 号，然后与新建文章的内容，然后进行发送这个异步的请求，就是整个这个 post 文章列表去找到对应的更新的那篇文章， 通过这个 id 号，这里我还进行了对于这个异步函数的抽象，因为会有多个请求方法，可以借助这个 axios 的类型，不同的方法，就可以进行。 弹出窗组件 这个也是属于这个全局的组件 首先要明确为什么，就是因为要对删除操作做出确认 分析 属性，显示隐藏，确认删除，取消删除事件， 由于子组件无法触发事件，单向数据流，就是子组件来定义发送事件，父组件来监听这个事件，并做具体事件的函数，子组件只是来定义这个事件，并去发送事件的。 对于 ref 对象的理解就是说这个，父组件为了能够给子组件传递属性的值，一般选取这个响应式的值。 梳理一下删除的逻辑，首先当我点击这个删除按钮会触发一个事件就是，首先要让显示值为 false，并且会去触发这个 action 删除文章的一个逻辑。 bug就是首先触发这个 action 的名字你得写对，还有这个就是，做组件不要急，你都没给 Button 添加事件你是怎么来，让这个 alert 框展示的，对吧，还有你&lt;teleprt 传送门是传的是到这个 id 号，#不要忘记了，还有你是给 Body 添加这个节点，不是给文档添加节点，你写 JSONP 的时候也用到了这个了 document.body 记住。 思路： 就是首先这个组件里根据这个弹框样式，就知道应该是有这个，title,还应该有显示的属性，并且应该向父组件发射两个，点击取消的事件，还有一个成功删除的事件。 父组件在点击这个删除后会触发一个函数这个函数就是去触发 action 删除文章后，并在一段事件后跳转至专栏页。 优化点 记录发送过的请求，防止重复的请求，用表示符号，每次发送一个请求的时候就是，将标识至反，然后就判断标识，所以可以不必重复的请求，但是单个的请求，布尔值不满足这个问题，所以我需要去做一个数组，每次请求过后的文章 id 号就 push 到数组里， 每次再次访问就去判断一下是否包含了这个文章 id,有了，就不用请求，如果不再这个 id 号，","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"暂时性死区","slug":"暂时性死区","date":"2020-02-13T12:22:00.000Z","updated":"2021-03-04T15:32:54.811Z","comments":true,"path":"2020/02/13/暂时性死区/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/13/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/","excerpt":"","text":"何为暂时性死区 首先说起这个问题，首先需要来明确一下这个var let const 的一些本质的一个区别，首先对于这个var 会有一个变量提升的问题，其实这个变量从未提升过，从执行上下文的角度来考虑，问题，首先创建的阶段对于你所声明的变量，会去开辟空间，然后到达执行阶段才去赋值，因为创建阶段先给变量赋值为undefined，，但是又由于js解释执行的时候是在之后，才有值所以是undefined.所以它的本质其实就是这个，全局执行上下文创建阶段和执行阶段两者不同步所造成的。 那么这个var同时还没有作用域的概念，所以在闭包常见题种循环输出只能拿到最后一次遍历的值，因为一旦用var来声明变量，首先这个var会被提升至全局，因为它没有作用域的这个概念，然后每次遍历这个var都是唯一的所以，不断被刷新了。 那么这个let const 就是说let 之所以没有变量提升的问题在于它将全局执行上下文的创建阶段和执行阶段都同步了，所以才不会出现这个，问题，并且添加了块级作用域的概念，也就是说，每次声明一个变量都会将其绑定到当前作用域内比如在函数中去。 const 就是声明的变量，不能被重新赋值，对于简单值类型，不能被重复改变值，但是对于引用类型的值，只要不改它的地址，可以修改比如对象里的值。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"js数组","slug":"js数组本质","date":"2020-02-03T13:20:47.000Z","updated":"2021-03-05T15:31:34.833Z","comments":true,"path":"2020/02/03/js数组本质/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/03/js%E6%95%B0%E7%BB%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"js 栈和堆个人理解就是简单数据类型，都放在栈中，复杂数据类型对象的地址存放在栈中，在堆中存储这个对象的值。 如果是 let a=1 a=’scx’ 对于简单数据类型的仅重新赋值，不会去开辟空间。 谁块：栈块，因为栈先进后出的数据结构更加的简单，栈是编译时系统自动分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。并且每次访问用类型数据都是先访问栈里的对象的引用，然后再去找堆里的对象。所以步骤多了，慢。 js 数组为什么不需要去分配固定的空间 v8 如何来实现这个 js 的数组。 js 里的数组是一个特殊的对象，为什么数组长度可变，为什么这个数组可以存储多个类型数据，因为是一个对象。快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，慢数组是用类似哈希表的形式创建的。 如果 v8 引擎发现数组内部出现了大量空洞，就是比如 arr=[1,3] arr[1222]=1 ,那就转为慢数组，因为不需要去申请大量连续空间，但是是以一种 hash 表来展示的。 慢转快；就是这个，js 数组的空洞少的时候就会去转换，这就是为什么 js 不需要分配固定长度的本质原因。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"csrf","slug":"csrf攻击","date":"2020-02-02T01:20:47.000Z","updated":"2021-03-15T03:36:57.668Z","comments":true,"path":"2020/02/02/csrf攻击/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/02/csrf%E6%94%BB%E5%87%BB/","excerpt":"","text":"csrf 怎么来理解，就是你想想，跨站伪造，就是攻击方提供一个接口，然后诱导用户点击它，然后在没有验证的基础上，向后端发送请求。 简单来讲其实就是，伪装用户向后端发送请求进行操作。 原理：就是在用户登录状态下，浏览器此时保存 cookie,用户点击了一个链接，这个链接就是网站的某个请求接口，然后浏览器会自动携带 cookie,进行请求，进行伪造身份。 怎么解决：就是可以借助 token，每次访问后端接口后，给前端页面表单标签里携带以一个 token,然后 cookie 也携带一个 token.由于用户点击的页面是拿不到页面的 token,所以服务器这里就不会通过这个请求。就是虽然 csrf 能够去，伪造用户，但其实由于浏览器的同源策略，客户端是拿不到这个 cookie 的，所以自然服务器，是无法进行验证通过的。 怎么来预防就是通过这个，post 接口， 因为一般如果借助 img 标签来攻击的话， post 想跨域要借助这个服务端的支持。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"js继承","slug":"继承","date":"2020-02-01T14:20:47.000Z","updated":"2021-03-12T08:26:30.177Z","comments":true,"path":"2020/02/01/继承/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/01/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承 首先来理解这个原型链继承就是将子类的原型对象直接变为，父类的实例，这样就可以通过原型链实现继承，从而拿到一些属性和方法 但是无法传递参数，而且会修改原型上的属性和方法，这里要注意一点就是要改变这个子类构造函数的指向，否则就顺着原型链指向了父类构造函数了，这个组合继承，寄生组合继承都要。 组合继承就是通过这个 call/apply 实现继承，首先子类实例一个对象，然后调用这个子类构造函数，之后再去调用这个父构造函数，改变这个父构造函数的 this 指向，这样并可以传递参数，这样，就给子类赋予了父类的属性和方法，并且由于构造函数声明的属性和方法都是私有的所以其它实例无法改变。并且还可以依赖原型链，去拿到这个父类原型上的方法，弊端就是父类构造函数调用了两次，一次是原型链上的，一次是这个 call 调用父构造函数的时候。 寄生组合继承：就是由于父构造函数调用了两次所以我需要，通过 object.create(父构造函数的 propotype),就是先来创建一个对象，然后让这个对象的_proto_指向这个参数。这样就跳过了这个父的实例，完美，不过也需要修改构造函数的指向。 123456789101112131415161718function parent(name, sex) &#123;//组合继承 this.name = name this.sex = sex parent.prototype.say = function () &#123; console.log(111); &#125;&#125;function child(name, age) &#123; parent.call(this, name)&#125;child.prototype = new parent()//第一次调用这个父构造函数child.prototype.constructor = child//修改这个原型constructor指向let a = new child()//第二次调用这个父构造函数 12345678910111213141516function parent(name, sex) &#123;//寄生组合继承 this.name = name this.sex = sex parent.prototype.say = function () &#123; console.log(111); &#125;&#125;function child(name, age) &#123; parent.call(this, name)&#125;child.prototype = Object.create(parent.prototype)//修改子类原型对象的__proto__为父构造函数的原型对象实现继承父的原型方法child.prototype.constructor = child//修改这个原型constructor指向","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"jsonp结合promise","slug":"jsonp","date":"2020-01-25T14:22:00.000Z","updated":"2021-03-12T08:30:16.246Z","comments":true,"path":"2020/01/25/jsonp/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/25/jsonp/","excerpt":"","text":"手写 JSONP 的实现思路 就是由于这个是一个异步的请求，所以需要用这个 promise,来做； …解构的应用： 与对象去使用就是在将里面所有可遍历的属性，进行拷贝。 for in 用来循环对象的属性的 let key for in object; key 就是对象里面的键； join 的用法就是说这个，将里面的值以什么来分割。 这个方法的弊端. 123456789101112131415161718192021222324252627282930function JSONP(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;) window[callback] = function (data) &#123; resolve(data) document.body.removeChild(script)//就是类似于我在做哪个全局loading组件的时候用到的添加节点就是往这个body里添加。 &#125; let arr = [] params = &#123; ...params, callback &#125; // a=1&amp;callback=s for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` document.appendChild(script) &#125;)&#125;JSONP(&#123; url: &#x27;https://loacl:2000&#x27;, params: &#123; a: 1 &#125;, callback: &#x27;s&#x27;&#125;).then(data =&gt; &#123; console.log(data);&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"requetAnimationFrame","slug":"requestanimation","date":"2020-01-25T14:21:00.000Z","updated":"2021-03-15T03:32:30.754Z","comments":true,"path":"2020/01/25/requestanimation/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/25/requestanimation/","excerpt":"","text":"requetAnimationFrame-js 动画 这个是 js 动画用的，就是来控制动画的更新频率为 60hz/s, settimeout 是手动来控制的而 raf 是浏览器自动控制的 浏览器如果切换到后台了，那么 raf 会停止，而 settimeout 会继续执行。节省资源 而且用 settimeout 还得算时间. 我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。 rAF 在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout 的例子来对比。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Tls1.2","slug":"TLS1.2握手协议","date":"2020-01-18T14:12:00.000Z","updated":"2021-03-05T13:53:58.111Z","comments":true,"path":"2020/01/18/TLS1.2握手协议/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/18/TLS1.2%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"总括 以ECDH算法举例 我现在要和一个人互相诉说小秘密，但是此时彼此都不知道身份，现在我和一个人进行碰面，在咖啡厅里会面，那肯定先得打个招呼。 但是由于我不知道对方的真实身份，所以我得需要对方发一个证明，验证身份我确认了对方是对的人了。 然后我和对方都把自己的一些小秘密(客户和服务器依赖于ECDHE子算法，彼此通过两个随机数生成了pre-master 随机数) 都整理好进行交换， 这样我们都知道了对方的小秘密。互相成了好基友 但是之后由于大家都很忙，所以我们互加微信，但是为了能够保证彼此的信息，不会被人拦截，所以我需要，对信息加密,就用之前彼此交换的秘密作为加密信息，进行对称加密 打招呼 验证身份 密钥交换 加密阶段 1. 打招呼阶段 客户端发消息 四个个信息 client hello 自己所支持的密码套件 以及TLS协议的版本号 用于密钥交换的，client random 那服务器回消息 四个确认信息 server hello 确认使用客户端所支持的密码套件 以及TLS版本号 密钥交换的server random 2. 身份确认阶段 服务器 服务器向客户端发了证书，用自己的私钥进行加密 同时服务器向客户还发了一个server params 此时双方都具有了用于密钥交换的两个参数（client params ,server params) 客户端 客户用公钥进行解密，确认了对方的身份之后 回了一个client params 此时双方都具有了用于密钥交换的两个参数（client params ,server params) 3. 密钥交换 客户和服务器依赖于ECDHE子算法，彼此通过两个随机数生成了pre-master 随机数 彼此综合三个随机数，各自生成主密钥 master-secret 用于之后对称加密信息. 之后发出加密算法通知，并发出finish（将之前的信息摘要）这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验。 TLS1.3","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTP缓存","slug":"Http缓存","date":"2020-01-15T14:20:00.000Z","updated":"2021-03-05T15:35:34.147Z","comments":true,"path":"2020/01/15/Http缓存/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/15/Http%E7%BC%93%E5%AD%98/","excerpt":"","text":"Http缓存为什么要有缓存如果你每一次的请求都让服务器去重新发送资源 这无疑是非常的低效的 如果说能够做到把一些重复申请的资源存放在缓存里而服务器不必每次都返回资源 这样能够极大的提升用户访问资源的效率 那我能够缓存哪些资源静态资源 img css js 哪些我不能缓存 html 为什么-因为html的结构可能会随着需求的变更而变更 流程强缓存 首次浏览器向服务器发出http请求 服务器返回资源，同时响应头部还包含一个cache-control里面是资源失效的时间（此时返回的同时将资源缓存到本地） 此时浏览器将资源与缓存的标识（1.LastModified,2.Etag）存放在本地缓存里 第二次请求资源 直接会访问本地的资源/同时要来判断资源是否过期 依据是什么cache-control，与客户端自己的时间进行对比 没有过期 本地缓存直接返回资源 过期了 协商缓存（对比缓存） 这里补充一下Etag 如果信息更新Etag也会去更新 它是根据内容来更新的 只要内容不变 Etag就不变 你先搞清楚它的意义 它就是用来对比服务器的资源和本地资源是否一致-从而确定是否有必要重新返回资源 此时携带着之前服务器所返回的缓存标识（Etag)发送请求给服务器 此时服务器再根据自己最新的Etag与客户端发来的Etag做对比 一致直接返回304给客户端 意思就是资源没有更新–可以继续访问原有本地缓存 不一致 直接返回新的资源给客户端","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]}]}