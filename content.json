{"meta":{"title":"Hexo","subtitle":"","description":"简单点","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[{"title":"categories","date":"2021-03-04T15:13:22.000Z","updated":"2021-03-04T15:13:22.763Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/HEXOS/hexos/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVAscript系统","slug":"JS知识体系","date":"2021-03-01T14:27:47.000Z","updated":"2021-03-22T12:49:19.147Z","comments":true,"path":"2021/03/01/JS知识体系/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/03/01/JS%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"js 基础js 基础数据类型隐式转换 ‘2’——‘0’ 可以将字符串转换为数字。（减号） ‘2’+ ‘2’可以进行字符串拼接”大数相加”。算法中用到了。进行结果相加 symbol: 可以用来定义一个绝对唯一的常量，避免命名冲突。 模拟私有变量，就是通过这个定义的属性是私有的，类似于之前通过立即执行函数，来实现的一个私有变量”闭包是如何来实现这个私有变量的”。 如何来区分数据类型 typeof 弊端就是只能区分简单类型的数据，对于复杂数据数组和对象都是 object 然后 typeof null= ‘object‘ (lao 老人)type of NaN = ‘number‘ (nn)。 instance of 就是对于 基本数据类型无法判断，并且只能判断无法返回具体的数据类型。//instanceof 弊端。它不能返回具体的数据类型。 Object.prototype.tostring.call(1) // [ object Number ]//更完美。 补充 Object.prototype.tostring.call(1)**原理：其实 Array, Boolean 也有一个 toString 方法，但是这个仅是转为字符串的,Object 上的 tostring 才是能够真正返回数据类型的，易错**：不是 Array 上的，我第一次记得是 Array 原型上的不对是顶层 Object 的方法，Array 类上的方法是改写过的，搞错了。Object.propotype.tostring.call 对于数组还可以用 **Array.isArray()**判断是否是一个数组。 valueof 和 toString value of 对于 Number string Boolean 显示其值，其它都是自身 tostring 除过这个 object {} 等为其类型，其它均为值，比如这个[].tostring=== ‘ ‘. 类数组 具有数组的长度，但是没有数组的方法，比如通过这个 queryselectAll 在调用 getElementsByTagName 和 document.childNodes 方法时，它们返回的 NodeList 对象都属于伪数组。返回的是一个类数组， 问题是怎么来转换这个数组，主要通过这个：[slice.call 方法的补充]1：**Array.from()**。 2: Array.prototype.slice.call(类数组)//就是首先 slice 会返回一个数组，然后 call 调用这个方法，然后改变 slice 里的 this,将其替换为类数组。 requetAnimationFrame-js 动画 这个是 js 动画用的，就是来控制动画的更新频率为 60hz/s, settimeout 是手动来控制的而 raf 是浏览器自动控制的 浏览器如果切换到后台了，那么 raf 会停止，而 settimeout 会继续执行。节省资源 而且用 settimeout 还得算时间. 我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。 rAF 在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout 的例子来对比。 闭包体系切入点词法作用域 首先我需要从作用域的底层机制说起，首先在 V8 引擎中是有编译阶段的，这里叙述”js 执行代码过程”。 这里还有一点就是此时引擎会在当前的作用域去寻找有没有所声明的变量，如果有那就忽略它，这也是为什么，var 可以重复声明的本质原因，如果没有的话就将这个变量存放在当前作用域，赋值阶段。 如何来叙述闭包 切入点词法作用域，那么词法作用域是怎样生成的（此时联想作用域里面有声明了一个变量），那么在编译阶段首先会来判断，当前的作用域有没有这个变量，有了就忽略，继续，没有就直接将变量放置当前作用域内并赋值 undefined. 那你不能光找到它，还得赋值，在当前作用域能找到直接赋值，没找到就不断向外部作用域找形成作用域链。 （谈到作用域本质就联想一个调用栈，里面压入了全局执行上下文，和函数执行上下文））作用域的本质到底是什么，从表层意思来讲，它是一套规则，存放相应变量的规则，从本质上来讲，它是当前所处执行上下文，从这一点可以明白，为什么闭包中，可以从内部访问外部的变量，而外部无法访问内部的变量，全局执行上下文首先会推入调用栈中，之后每当调用一个函数，就会将函数上下文推入栈中，所以即便调用栈中，栈顶执行上下文，执行完毕后出栈，但是内部执行上下文依然可以通过，作用域链来访问，但由于栈顶执行上下文出栈了作用域链也被销毁了，所以无法访问调用栈中上下文的变量。 补充词法作用域 所谓词法作用域本质就是，作用域的形成是在你所定义的位置，而不是你所调用的位置，这一点区别于动态作用域，它是在你所调用的时候，而不是你所定义的位置。 闭包应用。 var a = []; for(let i = 0;i&lt;10;i++)&#123; a[i]=function()&#123; console.log(i) &#125; &#125;; a[2](); 123456789101112131415161718192021 let 定义的 i 会运行 for 的块级作用域中，每次执行一次循环，都会创建一个块级作用域。 在这个块级作用域中，你又定义了一个函数，而这个函数又引用了函数外部的 i 变量，那么这就产生了闭包，也就是说，所有块级作用域中的 i 都不会被销毁，你在这里执行了 10 次循环，那么也就创建了 10 个块级作用域，这十个块级作用域中的变量 i 都会被保存在内存中。 那么当你再次调用该 a[n]() 时，v8 就会拿出闭包中的变量 i，并将其打印出来，因为每个闭包中的 i 值都不同，所以 a[n]() 时，打印出来的值就是 n，这个就非常符合直觉了。 但是如果你将 for 循环中的 i 变量声明改成 var，那么并不会产生块级作用域，那么函数引用的 i 就是全局作用域中的了，由于全局作用域中只有一个，那么在执行 for 循环的时候，i 的值会一直被改变，最后是 10，所以最终你执行 a[n]() 时，无论 n 是多少，打印出来的都是 10. 那么这就是 bug 之源了。2. 循环打印 1，2，3，4，5 和第二种思路比较相似，同样是在 setTimeout 外面再套一层函数，只不过这个函数是一个**立即执行函数** 。利用立即执行函数的入参来缓存每一个循环中的 i 值： &#96;&#96;&#96;js for (var i &#x3D; 0; i &lt; 5; i++) &#123; &#x2F;&#x2F; 这里的 i 被赋值给了立即执行函数作用域内的变量 j (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125; //就是每一次 settimeout 里的 j 对外部立即执行函数里的变量造成了引用，所以，缓存了这个值，因为 v8 不再回收这个被引用的值了，缓存了下来。 高阶函数 闭包的应用模拟私有变量 模拟私有变量：就是之前像是 Java c++ 这些，有 private 私有变量， 就是不是这个类的其它成员，你无法去访问这些私有变量。 在 js 生成一个类是依赖于这个构造函数，但是你实例化一个类会发现，你通过这个类可以访问到这些这个类的属性，但是这个有一个问题就是说，万一我在这个这个构造函数里定义了一些私密数据，那不就可以在这个对象去访问到这个属性了吗。 用立即执行函数，形成一个闭包，返回一个类，然后将私有属性放在函数里，不去通过 this 来赋值，直接进行赋值操作；a=privatedata，这样外部是无法拿到这个私有变量的。 还可以用”symbol:”.来模拟一个私有的变量。 偏函数 bind 的实现 “bind”. 柯里化防抖节流 “防抖&amp;节流”。 手写一个闭包 function cache()&#123; let res=&#123;&#125; return &#123; set: function(key,value)&#123; res[key]=value &#125; get: function(key,value)&#123; return res[key] &#125; &#125; &#125;//这里函数作为了返回值，并且这个内部返回的函数引用了外部的局部变量。 123456789101112131415## 模块规范（commonJS、es6 、AMD、CMD）1. [commonjs 和 es6 之间的区别](https:&#x2F;&#x2F;coding.imooc.com&#x2F;lesson&#x2F;320.html#mid&#x3D;38779)。[AMD CMD 区别](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;chenwenhao&#x2F;p&#x2F;12153332.html) 1：语法不同 2：后端： commonjs 是执行时引入，而这个 ES6Module 是这个静态时引入编译时引用，自己理解就是，es6 比如我 vue3 的项目中全部都用的是 es6 映入放在 script 标签的最外部，如果在使用的时候再去用会报错，编译阶段就要引入完成，而不是等执行 js 语句的时候再去引用了，然后这个 commonjs 就是动态，按需用， 哪里需要再引用。 3 ：就是这个 path.resolve 取绝对路径,webpack entry 就是要用到这个绝对路径，join 就是这个相对路径2. 但是 commonjs 是同步的，如果网络请求出现了阻塞那么就会导致这个页面阻塞，所以运用这个 CMD 和 AMD （addvance)，就是 提前定义加载所有依赖，CMD 是需要时再加载依赖.3. 你觉得 CommonJS 为什么不能做 Tree-Shaking ?4. AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行 CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖。1. &#96;&#96;&#96;js + &#39;123&#39; &#x3D; 123 特点：最终结果一定是一个数字类型 相关参考链接 js 基础体系跨域问题 浏览器同源策略：就是不同 url 之间无法互相访问资源，比如百度的不能访问阿里的资源，比如，用户登录 a 网站，然后不小心点击了危险网站，然后，这个网站向 a 网站发起 AJAX 请求，这样，就可能获取到了用户的登录信息。不同端口号，还有协议，域名不同都不可以。 JSONP：就是客户端这里去定义一个函数，作为参数，然后后端解析参数拿到这个函数，并带上参数并返回。这个弊端就是仅支持这个**get **请求的方法。 nginx 反向代理就是说这个浏览器访问 HTML 文件，但是没有涉及对接口的访问的时候，直接就是通过 nginx 将 HTML 文件返回，如果涉及对接口的访问，nginx 代理到 node.js 上的服务上来，然后返回相应的资源；所谓反向代理就是客户端不清楚具体是哪个服务器提供的数据内容。而正向代理就是客户端能控制访问哪个服务器的。 跨域不能共享 Cookie 但是可以知道用户的唯一标识符，通过用户唯一标识与同时接入的第三方平台实现数据共享。 数组方法weakmap weakset 首先联想这个 weak 是弱的意思，弱应用，就是键是弱引用类型，具体来讲就是一旦这个引用断开，或者说改变了地址的时候就会去销毁这个 value 值，再具体，点就是 key=null;key=new Array() 这样就可以，让 v8 引擎判断这个键值对可以销毁了。防止内存泄漏。//不是特别的理解 ❓。 join(‘&amp;’)//“1.join()”.就是将数组转换为字符串。里面的元素并以参数相隔开。”jsonp”.中用到了这个方法。 set: 就是集合，没有重复的元素，只要往里通过.add() 方法去添加元素。//并且 set 所返回的集合是一个”类数组”。所以需要转为真正的数组。”类数组转换”。 push / unshift这个 API 就是 push 的反向操作首先应该联想到这个 ushift. every:就是执行回调针对每一个元素，并且都通过，回调函数里的条件 slice 和 splice 的区别 你如何来看待 JavaScript JavaScript 借鉴了很多语言的特性，比如 C 语言的基本语法、Java 的类型系统和内存管理、Scheme 的函数作为一等公民，还有 Self 基于原型（prototype）的继承机制。毫无疑问，JavaScript 是一门非常优秀的语言，特别是“原型继承机制”和“函数是一等公民”这两个设计。JavaScript 的设计思想不过 JavaScript 也是一门处处是坑的语言，由于历史原因，很多错误的或者不合理的设计都被延续至今，比如使用 new 加构造函数来创建对象，这种方式的背后隐藏了太多的细节，非常容易增加代码出错概率，而且也大大增加了新手的学习成本；再比如初期的 JavaScript 没有块级作用域机制，使得 JavaScript 需要采取变量提升的策略，而变量提升又是非常反人性的设计。还有就是不太适合大型项目，因为项目中变量类型错误的情况，动态类型，执行时才检测数据类型的问题，所以才产生了 ts 尤其是接口的概念，减少了数据类型的问题。 个人理解： 吸收了 Java 的垃圾回收机制，self 的原型继承，scheme 的一等公民（scheme 是一等一的强，其它都往边上站）。c 语言的基本语法，但是早期的 js 没有块级作用域的概念，有变量提升，的 bug。 动态类型，弱类型（可以给一个变量赋予不同类型的值），解释型语言。单线程的 . NaNNumber.isNaN() / IsNaN 为什么引入： NAN!==NAN 我没有办法去判断一个数值是不是 undefined. 易错点就是说这个是判断不是数字的变为 true,是数字的为 false. isNan :原理是转换为数值类型，然后再去判断是否为 NAN，不能转换为数值型的都为 NAN,所以对于这个，‘aa’字符串也是一个 NAN **对于 undefined 由于也能转为这个 NAN,所以不精确。**（联想记忆：s（is you 是你吗，数值，）） Number.NaN() 不转类型，严格判断 NAN 类型，是 NAN 的那就为 true，其它都为 false. js 栈和堆个人理解就是简单数据类型，都放在栈中，复杂数据类型对象的地址存放在栈中，在堆中存储这个对象的值。 如果是 let a=1 a=’scx’ 对于简单数据类型的仅重新赋值，不会去开辟空间。 谁块：栈块，因为栈先进后出的数据结构更加的简单，栈是编译时系统自动分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。并且每次访问用类型数据都是先访问栈里的对象的引用，然后再去找堆里的对象。所以步骤多了，慢。 js 数组为什么不需要去分配固定的空间 v8 如何来实现这个 js 的数组。 js 里的数组是一个特殊的对象，为什么数组长度可变，为什么这个数组可以存储多个类型数据，因为是一个对象。快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，慢数组是用类似哈希表的形式创建的。 如果 v8 引擎发现数组内部出现了大量空洞，就是比如 arr=[1,3] arr[1222]=1 ,那就转为慢数组，因为不需要去申请大量连续空间，但是是以一种 hash 表来展示的。 慢转快；就是这个，js 数组的空洞少的时候就会去转换，这就是为什么 js 不需要分配固定长度的本质原因。 js 的栈和堆。 布尔值转换规则 布尔值转换规则。 个人理解：就是对于 undefined, nAN,NULL, ‘ ‘, 0:(+0,-0) (记忆：boolean,布尔是联合国的但是很穷，穷光蛋 0） 内存泄漏 内存泄漏相关问题内存泄漏问题。 对于那些 ``` 123456function neicun ()&#123; a&#x3D;1&#125;&#x2F;&#x2F;在js中如果没有声明直接赋值，会将这个变量提至全局对象，那gcroot不就可以访问到了吗，自然也没办法清除了 定时器忘清除了，那也就是说这个防抖和节流，如果不注意清除定时器，这就会导致内存泄漏的问题了。 10. null 和 undefined 的区别是什么123console.log(null&#x3D;&#x3D;undefined)&#x2F;&#x2F;true&#x2F;&#x2F;注意这个是双等号，就是隐式转换了console.log(null&#x3D;&#x3D;&#x3D;undefined)&#x2F;&#x2F;false null： Null 类型，代表“空值”，代表一个空对象指针 undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的是 undefined undefined 表示“缺少值”，此处应该有一个值，但是还没有定义。 null 表示“没有对象”，该处不应该有值。 遍历 for of for in for in 遍历的是键，也就是索引号，而且会遍历继承的属性，一般会配合 hasOwnPropoty,来去除从原型链上继承的属性，有的对象里的值会继承至原型链上的，比如 obj ={a:1},Object.propotype.b=1,obj.b=1,这样不就不是自身的吗。//hasOwnProperty. 所以这个联系”深拷贝”。 for of 和 for in. es6 … … 第一个作用可以将数组转换为 …[1,2]= 1,2 ;写 bind 扁平化迭代实现。 正因为这个特点，可以去重一层数组. 还可以去拷贝一份数组，就是在迭代中实现数组扁平化中用到 还可以去合并两个数组 […arr1,…arr2] == 和===区别 a=&#123;a:1&#125; b=&#123;b:1&#125; 123456789101112131415161718192021222324252627282930313233343536a&#x3D;&#x3D;b a&#x3D;&#x3D;&#x3D;b 都是 false### 原型### 高阶函数1. **高阶**函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。比如这个 map,reduce 等.2. **联想记忆**：为什么**高阶**，因为是属于，函数**一等公民**：所以高级---》就是函数可以做数据类型也能做的事情，比如这个，参数和返回值。### 继承1. [js 继承易懂](https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1a5411a7n3?t&#x3D;1656)2. [js 继承可参考视频](https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1J54y1y7u9?from&#x3D;search&amp;seid&#x3D;7963754240755905813)。3. 首先来理解这个原型链继承就是将子类的原型对象直接变为，父类的实例，这样就可以通过**原型链实现继承**，从而拿到一些属性和方法，但是无法传递参数，而且会修改原型上的属性和方法，这里要注意一点就是要改变这个子类构造函数的指向，否则就顺着原型链指向了父类构造函数了，这个组合继承，寄生组合继承都要。4. 对于这个**组合继承**就是通过这个 call&#x2F;apply 实现继承，首先子类实例一个对象，然后调用这个子类构造函数，之后再去调用这个父构造函数，改变这个父构造函数的 this 指向，这样并可以传递参数，这样，就给子类赋予了父类的属性和方法，并且由于构造函数声明的属性和方法都是私有的所以其它实例无法改变。并且还可以依赖原型链，去拿到这个**父类原型上的方法**，**弊端就是父类构造函数调用了两次，**一次是原型链上的，一次是这个 call 调用父构造函数的时候。5. **寄生组合继承**：就是由于父构造函数调用了两次所以我需要，通过 object.create(父构造函数的 propotype),就是先来创建一个对象，然后让这个对象的_proto_指向这个参数。这样就跳过了这个父的实例，完美，不过也需要修改构造函数的指向。6. &#96;&#96;&#96; function parent(name, sex) &#123;&#x2F;&#x2F;组合继承 this.name &#x3D; name this.sex &#x3D; sex parent.prototype.say &#x3D; function () &#123; console.log(111); &#125; &#125; function child(name, age) &#123; parent.call(this, name) &#125; child.prototype &#x3D; new parent()&#x2F;&#x2F;第一次调用这个父构造函数 child.prototype.constructor &#x3D; child&#x2F;&#x2F;修改这个原型constructor指向 let a &#x3D; new child()&#x2F;&#x2F;第二次调用这个父构造函数 12345678910111213141516function parent(name, sex) &#123;&#x2F;&#x2F;寄生组合继承 this.name &#x3D; name this.sex &#x3D; sex parent.prototype.say &#x3D; function () &#123; console.log(111); &#125;&#125;function child(name, age) &#123; parent.call(this, name)&#125;child.prototype &#x3D; Object.create(parent.prototype)&#x2F;&#x2F;修改子类原型对象的__proto__为父构造函数的原型对象实现继承父的原型方法child.prototype.constructor &#x3D; child&#x2F;&#x2F;修改这个原型constructor指向 ES6 和 ES5 继承的关系 审题不清，这轮面试要挂了。 再补充一点： ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。 es6 和 es5 的继承 异步async await异步.emmx. window.onload 和 window.Domcontentloaded 其实主要区别就是 onload 事件触发时，所有资源加载完毕。 而 domcontent 故名思意其实就时，仅 dom构建完毕就可以去执行了。 易混淆知识点 return ：直接跳出当前的方法,返回到该调用的方法的语句处,继续执行,在循环的语句中是去，直接返回了外部的函数。 break：在循环体内结束整个循环过程 continue ：结束本次的循环，直接进行下一次的循环. js 设计模式代理模式：代理模式。 预加载 保护代理，就是 vue3 用 proxy 来实现这个。 proxy(obj,{get: ()=&gt;{},set:()=&gt;{}})，第一个对象是目标对象，然后第二个参数，代表着，定义这个代理的行为。 原型模式 首先谈一下原型模式：其实就是一种原型编程范式，通过原型链来实现继承。在 js 中是通过实例，来实现对属性和方法的继承。 就是这里去画图理解；就是画一个原型链，就行这里相信自己，自然大胆说就好。 所谓原型链，就是会首先会查自生有没有相应的属性，如果没有就会沿着原型链去向上寻找是否有。 其实就是提供了一种属性查找机制。 function A() &#123; this.name = &#39;a&#39; this.color = [&#39;green&#39;, &#39;yellow&#39;] &#125; function B() &#123; &#125; B.prototype = new A() var b1 = new B() var b2 = new B() b1.name = &#39;change&#39;//这个是写操作。只有读操作才会去走的是原型链机制， name.sx=..这个会给对象直接挂载一个，属性。这个我理解错了，那也就是说下次看到写操作就要反应上来这个其实是，直接挂载，而不是原型链机制。 b1.color.push(&#39;black&#39;) console.log(b2.name) // &#39;a&#39; console.log(b2.color) // [&quot;green&quot;, &quot;yellow&quot;, &quot;black&quot;] js 作用域链 首先想到何时形成 作用域嵌套的时候就，可以形成这个作用域链了，想象（函数嵌套内部函数引用了外部变量）w–》闭包 同时引出为什么为什么外部变量不能访问到内部的变量。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"手写Promise","slug":"promise","date":"2021-02-25T14:22:00.000Z","updated":"2021-03-24T01:33:27.384Z","comments":true,"path":"2021/02/25/promise/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/25/promise/","excerpt":"","text":"手写 Promise思路码云地址 promise思路 首先搭框架 then()方法是每一个实例化对象都拥有的可以通过原型链去寻找。 promise的状态是私有的也就是说每一个实例化的状态都是在构造函数上，你每一次去实例化一个对象，都会去通过构造函数初始化其对应的状态。 牢记一点就是只要凡是私有的方法属性，都放在构造函数上，为什么因为你每次实例化一个对象都会重新通过构造函数生成一个新的属性，和方法，因为resolve和reject是执行器内部的，所以，不用将其传至下一个promise，所以我需要来放到构造函数内部. 这里为什么一定要将里面的value传递到，then方法里面，而这个then是原型上的方法，那么我可以给实例添加value,reason属性，这样就可以在实例中拿到这个值传递给then.//这里还是有些不清楚 每一次调用resolve，都会将这个里面成功或着失败的值全部都放到这个，this.value上. 为了能够实现不能连续的更改这个状态，所以限定只有是pending状态，才可以来改变你成功/失败的状态，否则不可以更改. 如果说突然抛出异常了.就相当于调用了reject 然后将错误的原因reject(error). 这里有一个小问题 就是说，then里的第二个失败回调，和catch有什么区别. 但是这里有一个问题就是说，如果说立即执行函数里有一个settimeout 宏任务，怎么办，就是可以把对应的then里成功的回调和失败的回调，全部push到相应的数组，里然后等到执行了settimout里的回调后，再去执行数组里的回调. 对于链式调用怎么来理解它就是说，第一个promise通过resolve来将其值传递到then方法里，所以只要在调用then的时候返回一个promise然后再去调用resolve，并将其值传递给resolve(x),这里不直接去返回这个promise其实是因为这个，要再决议程序中拿到这个promise来，来调用这个promise里的resolve,reject. 但是这里还需要来考虑一点就是说，这个x值可能为普通值，也可能为一个promise,所以来处理一下就是说，当这个对象为成功就执行resolve，如果为失败就去调用其promise,的reject.//决议程序故名思意，其实就是再判断then函数返回的结果到底是一个普通值还是一个promise. 这里又有了一个新的问题就是说我现在想要拿到这个promise2但是更具js执行代码的顺序，由于此时promise2还未返回因此你拿不到，所以用一个settimeout来去将其放置宏任务队列等到这个promise2返回完毕后再去，拿到这个promise2.所以你要给每一个then方法里的方法都去判断一下是否是promise对象，通过函数来处理。 但是如果说then方法内部直接抛出了错误，怎么办–直接在settimeout定时器里面去try catch 什么意思就是说目前then方法返回一个promise2后去判断then里返回的结果，如果说直接抛出了异步的错误，那么就在settimeout里，去try catch 里的错误 决议程序这里就还是有一些问题就是说这个，通过then.call(x,y,r)调用then肯定会有一个成功的回调和失败的回调，继续去调用这个相应的resolve，和reject。 决议程序的理解 如果x和promise 都指向同一个对象，则以typeError为reason 拒绝执行promise。如果x 是Promise对象，则promise采用x当前的状态： 如果x是pending状态，promise必须保持pending状态直到x的状态变为resolved或者rejected。 如果x是resolved状态，用相同的值value执行promise。 如果x是rejected状态，则用相同的原因reason执行promise。如果x是一个对象或者函数： 将promise的then方法指向x.then。 如果x.then属性抛出异常error，则以error为reason来调用reject。 如果then是是一个函数，那么用x为this来调用它，第一个参数为 resolvePromise，第二个参数为rejectPromiseⅰ. 如果resolvePromise以值y为参数被调用，则运行 [[Resolve]](promise, y)。ⅱ. 如果 rejectPromise 以据因 r 为参数被调用，则用原因r执行promise（reject）。ⅲ. 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则使用第一次调用并忽略剩下的调用。ⅳ. 如果then抛出了异常 error如果 resolvePromise 或 rejectPromise 已经被调用，则忽略它。否则用error为reason拒绝promised. 如果then不是function，用x为参数执行promise如果x不是一个object或者function，用x为参数执行promise。 promise.all 实现思路 首先明确它会返回一个promise对象，并且值是新的一个数组。 由于需要所传入的数组中的元素进行遍历，对待promsie对象需要去，调用对应的then方法里成功的回调，和失败的回调。有一个失败，直接调用reject方法，就可以使其状态成为失败，并且无法，逆转状态。 如果不是promise对象，直接调用存储新数组的函数，将其下标，和值进行存储。 复盘promise问题 自己有一个非常严重的问题就是这个，没有理解这个构造函数的用处，我用构造函数是为了能够私有化数据，其它实例化对象无法访问，所以，不仅你的状态是在这个构造函数里面，还有你的resolve，还有这个reject也应该是在这个构造函数里，因为ressolve,reject是你传递到promise里的函数，不是通过这个原型链上继承的. 自己写这个resolve的时候没有注意这个把值改变，因为每次你调用这个resolve，都需要在then中通过这个value,和reason来拿到这个值，所以你需要改变这个value,reason.还有要注意这个只有在状态为pending 的时候才可以去改变，状态不能逆转. 对于立即执行函数里面再加上一个定时器，不清楚，还有对于决议程序其实是为了能够判断then的执行结果是一个promise还是普通值，如果是一个promise的话那就去更具决议程序去判断，不是那就按照普通值去处理， 对于立即执行函数，里的定时器，自然调用这个then的时候要考虑这个，状态为pending的时候，只有这样，才可以去，先把成功的回调push进去，失败的回调也push进去，典型的发布订阅模式。 promise.finnaly手写 首先这个思路就是无论promise对象的状态是成功还是失败都会去触发的函数。 首先这个题就是说，首先联想这个finnaly是能够再次then，联想then具有链式调用的功能，那也就是说，这个finnaly其实是类似于用then来模拟的，所以，所以来找到这个调用finnaly的对象里的then方法，并且无论是all,race,finnaly都返回的是一个promise但是我想用.resolve，因为它可以等待里面的promsie执行完毕，因为这个finnaly(func)func有可能返回的是一个promise，并且可能设置了定时器，为了能模拟finnaly等待的过程，必须设置。 promsie.finnaly还能够去继续链式调用， 所以内部返回了一个promise并执行内部回调后，还要继续调用then方法，并且为了能够将value这个值让之后的then拿到需要用到这个then方法。 复盘再次出错，首先你应该明白的是，你用这个finnaly，它本质是一个then，那也就意味着会有一个失败的回调函数会去执行，那也就是说会，还有Promise.resolve是什么原理，这个promise就是es5里的函数，那也就是说，这个是构造函数，那我在构造函数里是不是定义过这个resolve,所以我能拿到这个值。 拿这个promise.resolve所包裹的函数，会等待这个函数执行完毕，才会去继续调用这个。 finnaly还有一个问题就是不会去改变对象的状态所以，在执行这个失败的回调的时候，是用了throw,这样就可以去让之后的catch来执行了。 promise.race 思路就是race故名思意就是一个竞赛，看谁先返回状态。所返回的promise就是什么状态，通过调用相应的resolve，reject 这里我有一个误区就是，对待非promise对象直接resolve,就好，在相应的then去调用相应的resolve,reject,来改变race返回的promise对象的状态，所以then不用返回，只是来改变返回promise的状态的。 const Pending = &#39;pending&#39; const Resolved = &#39;resolved&#39; const Rejected = &#39;rejected&#39; const resolvepromise = (promise2, x, resolve, reject) =&gt; &#123; if (promise2 === x) &#123; return reject(new TypeError(&#39;不能返回自身&#39;)) &#125; if (typeof x === &#39;object&#39; &amp;&amp; typeof x !== null || typeof x === &#39;function&#39;) &#123; //由于测试的时候即调用成功，也调用失败resolve(),reject() try &#123; let then = x.then if (typeof then === &#39;function&#39;) &#123;//是一个promise then.call(x, y =&gt; &#123; resolvepromise(promise2, y, resolve, reject)//什么意思就是说这个，resolve可能继续返回一个promise，所以想递归不断得到一个普通值后再去返回 &#125;, r =&gt; &#123; reject(r) &#125;)//这里为什么是x &#125; else &#123; resolve(x)//这里就是说这个x亦可能是普通值then里面返回一个普通值自然，调用promise2的一个resolve(x) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; &#125; class Promise &#123; constructor(executor) &#123; this.status = &#39;pending&#39; this.value = undefined this.reason = undefined this.onResolvecallbacks = [] this.onRejectecallbacks = [] let resolve = (value) =&gt; &#123; if (this.status === Pending) &#123; this.value = value this.status = Resolved this.onResolvecallbacks.forEach(fn =&gt; fn()) &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === Pending) &#123; this.reason = reason this.status = Rejected this.onRejectecallbacks.forEach(fn =&gt; fn()) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125; then(onsuccess, onreject) &#123; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === Resolved) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onsuccess(this.value)//普通值，这里是想来获取第一次的then的成功函数返回的结果 resolvepromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125; if (this.status === Rejected) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onreject(this.reason) resolvepromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125; if (this.status === Pending) &#123; this.onResolvecallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onsuccess(this.value) resolvepromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) this.onRejectecallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onreject(this.reason) resolvepromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; &#125;) return promise2 &#125; }","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"vue3项目笔记","slug":"知乎专栏项目笔记","date":"2021-02-20T13:48:45.000Z","updated":"2021-03-22T12:42:07.439Z","comments":true,"path":"2021/02/20/知乎专栏项目笔记/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/20/%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8F%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"7-7vuex 对于 vuex 中的这个通过 actions 去定义获取信息的函数，然后通过在对应的组件中通过这个 commit 来触发这个 mutitions，所以通过这个来实现。 这里的逻辑就是说这个通过在渲染这个一个 id 号下的所有文章的时候，通过，拿到路由里对应的 id 号然后去通过 dispatch 去触发对应的 actions 然后再去在 store 里来修改这样的状态。 亮点通过 async 和 await 来改造 actions 里的异步请求： 项目中遇到了哪些困难 怎么解决的就是在发出异步请求的时候总是返回 500 首先我打开浏览器去发现了自己 url 格式有问题，就是我 dispatch 的时候传递了错误的数据，导致最后拼接 url 的时候出现了错误。 运用 teleport实现组件挂载到另一个节点的时候，我还要去创建一个 div 标签，很不人性化 为什么要在 setup 这个生命周期函数创建就是因为要先在组件渲染完之前创建节点。同时由于你每次渲染一次组件，就创建一个节点，那么就在组件渲染完毕后再去销毁这个节点。 重点：权限管理 token,这里有一个小的问题就是自己错误在于自己在拿到这个 ref 的值得时候没有赋予 val 值。 这里的业务逻辑就是说这个客户这里登录成功后向服务器这里发出一个 post 请求，然后，拿到一个 token，那么这个到底是干什么的。 这里回顾一下，session 怎么来实现登录的，首先在博客项目里，我先通过制定的登录路由，登录，验证通过后，服务器这里创建对应的 session 来将其信息进行保存并存储在这个 Redis 里，之后向客户端这里返回一个 cookie：对应的 sessionid，然后，浏览器存储，当访问需要登录权限的路由时，客户端将 sessionid 通过 cookie 带上，然后通过服务器的验证后就可以返回对应的信息。弊端是什么想一想。 jwt： 一句话，就是信息都存储在客户端 ，而不是存储在服务器里，每次登录成功后，返回一个 token 字段，然后客户端下次访问需要验证的路由时，带上它通过 axios.commn-header，服务器反向验证，通过后就可以直接返回相应的信息了，好处就是减轻服务器压力. 亮点：那么现在我每次刷新，都会重新登录我该怎么来持久化这个状态呢，这里的逻辑就是说这个每次下次登录首页刷新时区判断一下当前未登录，并且，token 值存在，这个值被我存储到了 storage 里，再次添加 token 头字段，进行权限认证通过后，通过访问用户信息的路由，就可以去拿到对应的信息了，并将信息返回并渲染至界面上。 全局组件 message 首先出错这个组件不止是在，某个组件中去用，全局状态下都有可能去用 首先这个全局组件，需要设置一个错误的一个数据结构。一般全局组件的设计思路就是说通过 store 设置全局的状态，并通过这个拦截器，来拦截这些状态，// 这里就是通过失败的回调得到失败的数据，并commit去触发全局错误状态的改变。 这里有一个小问题就是现在当我去点击这个取消错误提示的时候，发现，这里不去显示这个组件了这是为什么，这里对于这个全局组件的理解应该是一个函数，而不是单纯的一个组件，因为这样子我就可以去，传递一些错误的信息提示，以一种全局错误的一种调用就是我需要的时候去调用它，亮点：以函数的形式来创建一个组件，就是先创建一个应用，里面有组件，和 props 的参数，然后通过这个参数来解决这个问题，这里考点: watch 的应用 就是来监听这个全局错误状态的改变，一旦改变了就调用这个组件函数，并传递相应的一个参数。这里遇到的 bug首先就是我发现，点击的时候没有触发相应的事件，于事猜测可能就是这个，事件没有触发因此出现了问题，最后发现这个事件我添加在了外部的容器导致点击，那也就是说，你点击哪个元素就给它去添加事件，你不要去给它添加事件。 文件上传组件：亮点 首先明确一下由于文件上传的格式一般是二进制数据，所以的话需要这个采取 multipart/form-data ，支持二进制数据，难点和亮点就是说通过这个，fjavascript 来模拟这个文件上传。 首先来明确一下这个思路就是，我在点击一个 button 按钮的时候，，想触发这个 input 的上传文件，那么就在点击 button 的时候，给 input 去添加一个 click 事件即可，这里有一个泛型的应用就是可以去给这个 ref 对象去传递一个泛型，这里不是特别的理解， 这个组件的属性必然要有一个 action 就是你往哪里去串，这个 url 所以这个必然是 props 的属性。 设计思路就是首先我需要拿到这个 input file 这个 dom 节点，之后，问题： 拿到这个 dom 节点后，记得要把这个 ref 值往外导出，不然这个 dom 节点上你拿不到，你所定义的这个值，自然也拿不到这个 dom 节点。拿到这个 dom 节点后，当你去触发这个事件的时候，就会拿到这个 files 这个上传的文件，之后，去创建一个 form data 之后再去，将数据 append 到里面，最终在前端通过 post 请求，传递数据，以及设置这个数据类型以这个 mutiply-formdata 的数据格式发送请求。 亮点： 具名插槽的使用，何时用就是在你需要自定义模板的时候，去用，就是我在子组件里去通过定义 slot，并定义这个内容，然后父组件在向子组件传递内容的时候，借助于 template 模板来使用这个，并通过 v-slot 来确定往哪个插槽里去传递内容。 亮点： 如何在父组件中拿到子组件里，的值，，就是如何将子组件里的值，传递到这个父组件里面，，就是结合文档，子组件去定义一个需要向外传递的值，然后父组件在插槽里拿到这个值取渲染你刚才传递的这个照片。 如何来禁止这个属性继承，考点： 如何来让父组件的属性继承到子组件里，通过绑定这个 $attrs,就是在做这个希望让这个上传组件的样式进行自定义，那么我们就需要，在父组件定义属性，比如类名，还有内容。 自定义一个上传组件就是更具不同的状态，结合具名插槽，传递这个不同的状态，所对应的元素。 记录一下小 bug,就是说由于我最终是想去在上传成功的状态去，传递我所定义的成功是展示图片的插槽，但是我在 finnaly 最后又去重新赋值为这个状态为 ready 导致成功的插槽内容始终没有展示。 创建文章逻辑： 我是如何将这个 image 的 id 号和展示文章的 Id 号所对应的就是通过这个， bug: 自己在做的时候发现自己，把 post 的请求发出返回的结果没有注意这个格式，就是自己，因为后端的返回结果其实是把这个数据都放在了 data 里而我是直接跳过了这个 data 直接就继续找到了这个 data。 文章详情页的展示 首先点击按钮可以跳转至详情页，之后的话就是说这个，那就得继续来个路由这个路由出口展示着这个详情页。 分析这个组件设计的思路： 首先我需要这个创建对应的 views 因为是视图的改变，需要创建对应的路由。 在这个 columndetail 上去创建这个链接，跳转至对应的一个界面上去。 在 onmounted 的时候去发送这个单个文章的请求来返回相应的数据。 编辑删除区域 就是你文章详情接口返回了一个 author 数据，你要拿到这个数据里的 id 号和你登录的时候所对应的 id 号进行比对，如果一致的话，那就返回相应的数据，如果不一致的话， 那就不展示对应的编辑删除区域， 编辑模式下的创建文章，必然首先要在组件渲染的时候拿到这个图片进行展示，发出相应的请求进行展示，因为你想编辑模式下，必然是让这个头图，标题，还有文章，都要拿到相应的数据进行展示。 在这个 uploaded 进行数据的一个初始化，就是说这个，这里有一个问题就是说让这个在 props 里的属性进行改变的时候，进行 watch 监听，这样。 Bug:这里记录一下一个 bug，就是说这个我在触发 action 的改变的时候，发现拿不到数据，最后发现自己这个每次没有将自己通过发出 axios 的请求，所返回的数据返回，这就导致了，你通过触发这个 actions 始终拿不到我想要的数据。 对于编辑，删除，跟新的功能，其实通用的思想就是设置 action, mutations 然后，去触发。 对于这个更新文章的思路，就是我们在触发这个对应的 action 的时候是去拿到这个跳转时的 id 号，然后与新建文章的内容，然后进行发送这个异步的请求，就是整个这个 post 文章列表去找到对应的更新的那篇文章， 通过这个 id 号，这里我还进行了对于这个异步函数的抽象，因为会有多个请求方法，可以借助这个 axios 的类型，不同的方法，就可以进行。 弹出窗组件 这个也是属于这个全局的组件 首先要明确为什么，就是因为要对删除操作做出确认 分析 属性，显示隐藏，确认删除，取消删除事件， 由于子组件无法触发事件，单向数据流，就是子组件来定义发送事件，父组件来监听这个事件，并做具体事件的函数，子组件只是来定义这个事件，并去发送事件的。 对于 ref 对象的理解就是说这个，父组件为了能够给子组件传递属性的值，一般选取这个响应式的值。 梳理一下删除的逻辑，首先当我点击这个删除按钮会触发一个事件就是，首先要让显示值为 false，并且会去触发这个 action 删除文章的一个逻辑。 bug就是首先触发这个 action 的名字你得写对，还有这个就是，做组件不要急，你都没给 Button 添加事件你是怎么来，让这个 alert 框展示的，对吧，还有你&lt;teleprt 传送门是传的是到这个 id 号，#不要忘记了，还有你是给 Body 添加这个节点，不是给文档添加节点，你写 JSONP 的时候也用到了这个了 document.body 记住。 思路： 就是首先这个组件里根据这个弹框样式，就知道应该是有这个，title,还应该有显示的属性，并且应该向父组件发射两个，点击取消的事件，还有一个成功删除的事件。 父组件在点击这个删除后会触发一个函数这个函数就是去触发 action 删除文章后，并在一段事件后跳转至专栏页。 优化点 记录发送过的请求，防止重复的请求，用表示符号，每次发送一个请求的时候就是，将标识至反，然后就判断标识，所以可以不必重复的请求，但是单个的请求，布尔值不满足这个问题，所以我需要去做一个数组，每次请求过后的文章 id 号就 push 到数组里， 每次再次访问就去判断一下是否包含了这个文章 id,有了，就不用请求，如果不再这个 id 号，","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTPS问题自测","slug":"HTTPS体系","date":"2021-02-19T02:20:47.000Z","updated":"2021-03-15T07:50:34.859Z","comments":true,"path":"2021/02/19/HTTPS体系/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/19/HTTPS%E4%BD%93%E7%B3%BB/","excerpt":"","text":"问题一：HTTPS 它的认证加密过程是怎样，它怎么保证内容不会被篡改 首先由认证想到了身份认证，在 tls 握手阶段为了能够表明自己的身份，首先依赖于数字签名算法，就是首先会将密文用摘要算法，这些算法的特点就是单向性，和雪崩性，也就是说一旦中间人篡改一点点，摘要就会改变，然后此时用私钥（因为是唯一的）加密摘要，以及将公钥发送给对方，那么为了能够让客户端清楚是对的人发 的。 需要依赖于 ca 机构的证书，那么我将数字签名和公钥，都发给对方，对方接收到之后取出公钥然后验签，确认是对方了，就继续握手阶段。 那么它的加密过程是什么就是说在开始阶段，双方发给对方，发送 client random,server random ,验证身份阶段，服务器会发送 server params ，，客户端验签后会发送 client params , 彼此通过 ecdhe 算法算法出一个 pre-master. 双方此时具有三个参数（client random server random pre-master ） 生成 Master 主密钥，之后就用这个密钥进行加密信息。 那根证书怎么保证签发的证书是有安全有效的 此时联想一个证书链，浏览器是具备各大机构的根证书的，走证书链找对应的根证书 易错点就是自己这个，这个证书发布是服务器不是这个机构，机构只是给申请者颁布证书的，并且就是 ca 机构页会对服务器发的公钥来加密，然后接受方用内置的 ca 公钥来解密 ca 的私钥 CA 机构会用密钥对服务器的公钥进行签名，签名和加密，怎么理解 就是 ca 机构拿到这个，服务器发来的公钥，会用自己的私钥加密，形成证书的签名算法，之后呢就是，客户端保存有各大 ca 机构的公钥，然后进行解密，验证这个 ca 机构，这里是证书的签名，不是之前那个服务器，的签名算法，不要弄混了 如果发生无限套娃的情况，根证书都被篡改怎么办/或者说 https 一定是安全的吗？ 无解，因为证书体系的保障就是依赖于根证书的，这个都无法保障的话，确实无解。 HTTPS 用到了加密算法，加密算法都有哪些类型 首先对称加密算法，非对称加密算法，摘要算法里的单向加密也就是说只能加密不能解密。 对称加密：ACE chacha20 非对称加密： RSA ECDH 摘要算法： MD5 SHA-2 对称加密和非对称加密有什么区别吗 对称加密简单来讲就是用同一个公钥进行加密 非对称加密就是公钥加密，私钥解密，因为私钥是唯一的。补充：其实也可以用私钥加密公钥解密，就是数字签名算法了。 MD5、SHA、Base64 和 RSA 属于什么类型的算法，对称还是非对称？ MD5,SHA 属于摘要算法，，RSA 常用非对称加密算法。 Base64,用 64 个字符表示二进制（B）不是加密算法。 1. HTTP 和 HTTPS 之间有什么区别或者说改进 首先 TLS—》 是什么： 网景公司开发，一个协议，在哪： TCP/IP 协议栈中 HTTP 层之下，TCP 协议层之上，解决了 HTTP 安全性问题， 在 TLS1.2 握手协议（HTTP 和 HTTPS 是好兄弟需要握手）中由于身份认证，需要向 CA 机构申请证书。 然后还有一个细节就是 HTTPS 的端口号是 443，HTTP 是 80（S4，P 的吧（8）） 联想记忆路径： 由 S 联想到了 TLS， 把它想象一个人，查它户口，是谁，在哪，解决了什么问题，同时为了表明自己的身份，需要向 CA 机构申请证书。 2. HTTPS 具体是如何解决 HTTP 的安全性问题的 这个题就得从机密性，不可否认性，完整性，身份认证四个点来答. tls1.3 握手 简单来讲就是说讲之前的 hello 阶段与密钥交换阶段合并。一次信息交换，就可以产生 两个 random 随机数，以及两个 params。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"暂时性死区","slug":"暂时性死区","date":"2021-02-13T12:22:00.000Z","updated":"2021-03-24T01:34:45.621Z","comments":true,"path":"2021/02/13/暂时性死区/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/13/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/","excerpt":"","text":"何为暂时性死区 首先说起这个问题，首先需要来明确一下这个var let const 的一些本质的一个区别，首先对于这个var 会有一个变量提升的问题，其实这个变量从未提升过，从执行上下文的角度来考虑，问题，首先创建的阶段对于你所声明的变量，会去开辟空间，然后到达执行阶段才去赋值，因为创建阶段先给变量赋值为undefined，，但是又由于js解释执行的时候是在之后，才有值所以是undefined.所以它的本质其实就是这个，全局执行上下文创建阶段和执行阶段两者不同步所造成的。 那么这个var同时还没有作用域的概念，所以在闭包常见题种循环输出只能拿到最后一次遍历的值，因为一旦用var来声明变量，首先这个var会被提升至全局，因为它没有作用域的这个概念，然后每次遍历这个var都是唯一的所以，不断被刷新了。 那么这个let const 就是说let 之所以没有变量提升的问题在于它将全局执行上下文的创建阶段和执行阶段都同步了，所以才不会出现这个，问题，并且添加了块级作用域的概念，也就是说，每次声明一个变量都会将其绑定到当前作用域内比如在函数中去。 const 就是声明的变量，不能被重新赋值，对于简单值类型，不能被重复改变值，但是对于引用类型的值，只要不改它的地址，可以修改比如对象里的值。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS 栈和堆","slug":"js栈和堆","date":"2021-02-11T01:20:47.000Z","updated":"2021-03-15T07:49:25.941Z","comments":true,"path":"2021/02/11/js栈和堆/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/11/js%E6%A0%88%E5%92%8C%E5%A0%86/","excerpt":"","text":"js 栈和堆个人理解就是简单数据类型，都放在栈中，复杂数据类型对象的地址存放在栈中，在堆中存储这个对象的值。 如果是 let a=1 a=’scx’ 对于简单数据类型的仅重新赋值，不会去开辟空间。 谁块：栈块，因为栈先进后出的数据结构更加的简单，栈是编译时系统自动分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。并且每次访问用类型数据都是先访问栈里的对象的引用，然后再去找堆里的对象。所以步骤多了，慢。 js 数组为什么不需要去分配固定的空间 js 里的数组是一个特殊的对象，为什么数组长度可变，为什么这个数组可以存储多个类型数据，因为是一个对象。快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，慢数组是用类似哈希表的形式创建的。 如果 v8 引擎发现数组内部出现了大量空洞，就是比如 arr=[1,3] arr[1222]=1 ,那就转为慢数组，因为不需要去申请大量连续空间，但是是以一种 hash 表来展示的。 慢转快；就是这个，js 数组的空洞少的时候就会去转换，这就是为什么 js 不需要分配固定长度的本质原因。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSRF","slug":"csrf攻击","date":"2021-02-02T01:20:47.000Z","updated":"2021-03-24T01:34:21.897Z","comments":true,"path":"2021/02/02/csrf攻击/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/02/csrf%E6%94%BB%E5%87%BB/","excerpt":"","text":"csrf 怎么来理解，就是你想想，跨站伪造，就是攻击方提供一个接口，然后诱导用户点击它，然后在没有验证的基础上，向后端发送请求。 简单来讲其实就是，伪装用户向后端发送请求进行操作。 原理：就是在用户登录状态下，浏览器此时保存 cookie,用户点击了一个链接，这个链接就是网站的某个请求接口，然后浏览器会自动携带 cookie,进行请求，进行伪造身份。 怎么解决：就是可以借助 token，每次访问后端接口后，给前端页面表单标签里携带以一个 token,然后 cookie 也携带一个 token.由于用户点击的页面是拿不到页面的 token,所以服务器这里就不会通过这个请求。就是虽然 csrf 能够去，伪造用户，但其实由于浏览器的同源策略，客户端是拿不到这个 cookie 的，所以自然服务器，是无法进行验证通过的。 怎么来预防就是通过这个，post 接口， 因为一般如果借助 img 标签来攻击的话， post 想跨域要借助这个服务端的支持。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"进程和线程总结","slug":"进程线程总结","date":"2021-02-01T03:20:47.000Z","updated":"2021-03-15T03:42:08.135Z","comments":true,"path":"2021/02/01/进程线程总结/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/02/01/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"进程和线程的区别思路： 首先所谓的进程就是，资源调度的基本单位 线程就是依附于**进程的一个独立**的执行单元。 它俩的区别就是，一个进程可以有多个线程，线程依附于进程进程有独立的单元，也就是说一个进程的崩溃，不会影响其它进程，而一个线程挂掉，代表着整个进程崩溃，进程之间的内存难共享，而线程之间的数据是可共享的， 易理解思路： 线程在进程下行进（ 一个进程可以包含多个线程 不同进程间数据很难共享 同一进程下不同线程间数据很易共享 进程要比线程消耗更多的计算机资源 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉 进程可以拓展到多机，进程最多适合多核 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 进程使用的内存地址可以限定使用量 进程/线程之间如何来通信 进程之间通过管道（有这个有名字的无名字的管道）匿名管道，具名管道，消息队列，然后还有这个，信号量（发送消息）套接字，可用于不同设备之间的。 线程之间就是通过锁机制，读写锁，互斥锁，信号量机制，用来同步线程之间的消息的。 线程之间哪些资源共享，哪些不共享1 .标识线程的线程 ID，栈空间是私有的的，堆空间是共享的，全局变量是共享的。 死锁 概念： 多个进程，竞争资源导致的阻塞现象 条件： 1：互斥条件：就是资源非共享，想获取这个资源就得等这个资源被释放。2：不可剥夺：就是你不能随意占据已经被使用的资源，3：请求和保持：吃着碗里的看着锅里的，就是自己占着资源，但还在申请资源，同时不去释放资源。4：环路等待条件：（进程资源形成一条循环链）存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求。 怎么避免就是：银行家算法，判断当前系统是否存在安全序列，如果有那么就同意进程请求资源，不存在安全序列，就阻塞这个请求因为有可能发送死锁.","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"requetAnimationFrame","slug":"requestanimation","date":"2021-01-25T14:21:00.000Z","updated":"2021-03-24T01:33:20.648Z","comments":true,"path":"2021/01/25/requestanimation/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/25/requestanimation/","excerpt":"","text":"requetAnimationFrame-js 动画 这个是 js 动画用的，就是来控制动画的更新频率为 60hz/s, settimeout 是手动来控制的而 raf 是浏览器自动控制的 浏览器如果切换到后台了，那么 raf 会停止，而 settimeout 会继续执行。节省资源 而且用 settimeout 还得算时间. 我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。 rAF 在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout 的例子来对比。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSS知识体系","slug":"css知识体系","date":"2021-01-20T14:20:47.000Z","updated":"2021-03-22T12:40:15.390Z","comments":true,"path":"2021/01/20/css知识体系/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/20/css%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"CSS 知识体系响应式布局系统.rem. “. 问题二:什么是 rem 布局？rem 布局的缺陷。”。 叙述思路：： 首先由 r 想到 root –也就是说 HTML-fontsize 的大小，也就说 1rem 就是等于 HTML-fontsize 的大小 。 （补充 HTML 根元素 font-size： 16px）。由于是响应式的也就是说会变，的—》那不能变元素吧，只能是随着屏幕的变化，而通过 js 来动态的设置这个根元素的大小。 vw/vh “. 问题一：什么是 vw+vh 布局？有哪些有优点？有哪些缺陷？”. 由 v 想到了 viewport 也就是说视口宽高,也就是说这个，你屏幕的宽高，可视的嘛,但是它相对于设备视口的 1/100. 也就是说 1vw=1/100 width(可视宽：屏幕的宽高）。通过这个可以来计算，1px 与 vw/h 的关系从而能够完美实现响应式布局。 补充布局视口（HTML 网页的宽高），理想视口 ，视觉视口（用户当前所看到的宽高）。 rem/vw/vh 用 rem 更多还是从兼容性上说的，而 vw 更多的是从简易性考虑的，没有谁是完美的，我在项目中有用到过 vw 和 rem，觉得确实 vw 更具有实操性， css 习题. 1px 问题如何解决 为什么会出现这个问题，主要其实在于这个，会有一个比例值，设备的像素：window.devicePixelRatio（设备像素比例：ration:比例的意思）= 实际像素/css 像素。//弊端再于兼容性不好 直接写 0.5px:就是直接，先去给相应的元素设置这个，自定义属性：值为像素比例，然后通过属性选择器，去命中它，border 直接改为 0.5px。 利用伪元素，然后子绝父项，相对于目标元素定位，宽高设置： 两倍于目标元素，然后再次，利用 transform 来缩放 50%，之后，这样正好，就把 1px 转为 0.5px，了然后再去 × 比例系数=1px. #container[data-device=&quot;2&quot;] &#123; position: relative; &#125; #container[data-device=&quot;2&quot;]::after&#123; position:absolute; top: 0; left: 0; width: 200%; height: 200%; content:&quot;&quot;;//不写，伪类元素，没办法设置宽高了 transform: scale(0.5);//缩放一半 transform-origin: left top;//以哪个点来缩放 box-sizing: border-box; border: 1px solid #333; &#125; &#125; 12341. 首先：想到 viewport 为什么想到因为这个是视觉问题想到了视口：也就是说只要来控制2. &#96;&#96;&#96;html &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;initial-scale&#x3D;0.5, maximum-scale&#x3D;0.5, minimum-scale&#x3D;0.5, user-scalable&#x3D;no&quot;&gt; 那如果想要来改变里面的属性，通过 js 向 meta 这个 dom 节点设置新的属性，并且改变设备像素比例。 弊端：你想想这样做是将页面所有内容全部缩放了，文字图片也被缩小了，那怎么解决 我们可以通过调用 document.documentElement.clientWidth / clientHeight 来获取布局视口大小。 1px 问题的方案。 1px 解决方案。 慕课教程 1px 解决的方案 link 和@import link 和 import 区别。 &lt;link href&gt; 123456789101112131415161718192021221. 首先遇到这个问题先想自己平时引入的 CSS 样式，就是拿 Link 来引入的，这个是非常常见的。由由于这个是写在 HTML 里的也就是属于 HTML，其实就是一个 dom 节点所以可以通过 js 获取并更改。2. **浏览器在解析资源的时候遇到 link 标签，会发出一个异步请求引入的资源，而不会去，阻塞页面的加载，而@import 是**最后**才会被加载的资源**，所以最好用这个 link3. 兼容性，就是 link 属于 HTML 标签，没有什么问题，但是@import 是 CSS2.1 加入的也就是会存在兼容性问题。### CSS 定位问题1. absolute &#x2F; relative2. 首先明确一点就是子觉，父相，也就是说子元素一般是绝对定位，而父元素就是相对定位的，、3. absolute&#x2F;fix : 都会脱离文档流而触发这个 BFC 块。4. absolute 基于最后一个定位的父元素定位，最后一个定位的父元素指什么？5. 可以看到，「最后一个定位的父元素」指最后一个 position 不是 **static** (就是最近的定位元素)的父元素。6. absolute 在找不到最后一个父定位的元素，相对于浏览器窗口（viewport）定位的时候，和 fixed 有什么区别：就是 absolute 会随着滚动条滚动，而 fix 直接就定死。### src 与 href 之间的区别1. &#96;&#96;&#96; &lt;link href&#x3D;&#39;&#39;&gt; &lt;a href &gt; &lt;script src &gt; &lt;img src&gt; src 和 href 的区别。//b 站对于 src 和 href 之间的一个区别。 就是 src 就是下载这个资源，然后嵌入到这个节点内部,会阻塞这个页面的加载。 而 href（联想跳转这个动作）一般用于 a 链接，目的就是为了能够建立和外部资源的联系，不会阻塞浏览器解析资源.”link 和@import” CSS 选择器优先级别问题 就是给一个元素设置了多个样式，我该渲染哪一个 ！imporant 是最重要的 2：内联元素 3： id 选择器//id 是唯一的所以优先了。 4：class 类名选择器伪类元素 5：标签（直接 div span 设置样式），伪元素 （1，2，3，4，5） 最左边的值更大(但是序号所对应的数量，而不是权重值） 但是如果相同的话就是层叠覆盖，谁在后就用谁 CSS 选择器继承问题 就是 font-size ,font-weight,还有 color， line-height 。 CSS 画一个三角形 其实想象一个正方形，然后它的边框在外部，然后边框越粗，内容相应越短的时候，就会让这个边框无限向内收缩所有，也可以来设置上下左右边框的 border 的颜色来决定三角形的朝向。 flex 布局//联想实际布局不要死记 flex 有哪些属性 联想一个容器里面有两个元素，首先联想到这个 flex 的排列方向，是水平排列还是垂直排列。flex-diredtion:cloumn/row; 那如果元素太大，但是我又不想让它换行怎么办-flex-wrap :nowrap. 此时我又想让它水平，排开两边就用 justify-content: space between/center;//水平轴上的。 垂直轴上对齐怎么办：align-item: center/flex-start// 在垂直轴最上方对齐用. 这里有一个小的细节就是，flex-grow： 1 给某个元素设定后，它就会占慢剩余空间。 由于已经是 flex 布局了，所以 float clear vertical-aligen都将失效了 CSS 动画 平时动画怎么来实现的，首先动画分为 2d 的和 3d 的。 px em rem px pixel 像素，就是相对于屏幕分辨率而言的，就是图像里最小的点。 em， 相对于使用 em 的标签的 fonf-size 大小，易错点：这个不是取的是父元素的 font-size,因为这个是发生了 font-size 继承。div: font-size:20px width:em; width=20p; rem ，就是想对于 HTML 根元素的 HTML : font-size: 20px; 1rem =20px. 盒模型 首先盒模型有几个属性分别是 content border padding margin ; 盒模型有两种标准，第一种是 w3c（万维网联盟） 首先盒模型有几个属性分别是 content border padding margin ;就是实际元素宽高是考虑，边距和边界的。 你所设定的 height width **是不包括这个 **border 和边距（padding) 第二种：是传统的 IE 浏览器模型：box-sizing:border-box; 也有几个属性分别是 content border padding margin ; 实际元素的宽高是不考虑，这个边距和边界的。 但是其元素 width height的计算是包含了 border. 什么意思，就是说我可以并排的展示两个加上 border 超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距； box-sizing : content:box, : border-box : inherit 继承父元素的盒模型。 BFC 块 /IFC为什么设置 over-flow:hidden,可以清除浮动清除浮动元素.emmx. 要了解 bfc 块，内部的块级元素会垂直摆放，同属于一个 bfc 块会发生 margin 重叠，那么消除这样的 bug 就可以给其中一个元素在套一个容器让他成为令一个新的 bfc 块（还要设置一个 over-flow:hidden). 给父元素加了一个 over-flow:hidden 就是为了使用 bfc 块的特性：在计算 bfc 块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用 BFC 消除 margin 重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的 overflow:hidden;bfc 块的特性就是，紧贴浮动元素，所以直接就在两边。也可以用来去做这个浮动元素。 可以触发 BFC的属性有 float、position、overflow、display：table-cell/ inline-block/table-caption IFC IFC（Inline formatting contexts）：内联格式上下文 IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同 IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。 那么 IFC 一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 垂直水平居中原理margin: auto 原理 第一种可以用 flex 布局 1234 给父元素，去设置display:flex;justify-content:center&#x2F;&#x2F;水平居中； align-item:center&#x2F;&#x2F;垂直居中； #center &#123; background-color: red; width: 200px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; &#125; 12345678910111213141516171819202122232425261. [margin:auto 原理](https:&#x2F;&#x2F;www.imooc.com&#x2F;read&#x2F;70&#x2F;article&#x2F;2131)。1. auto 就是“一样”的意思，如果是左右 auto 的话，意思就是： 这个 DIV 离 左边的距离 跟 右边的距离 是一样的。 margin:0px auto；就是上下的距离是 0px，左右的距离是“一样”。2. **叙述思路**： 垂直方向上，auto 不会自动填充，水平方向上不会去自动填充，所以此时通过，绝对定位并设置上下左右边界，触发流体特性，这样垂直方向上就可以进行自动填充了，从而达到垂直方向上居中的操作。3. 1. 解释下原理: 1 在普通内容流中，margin:auto 的效果等同于 margin-top:0;margin-bottom:0. 2 position:absolute 使绝对定位块跳出了内容流 3 为块区域设置 top: 0; left: 0; bottom: 0; right: ;将给浏览器重新分配一个边界框 ，使元素具有流体特性，此时该元素的所有可用空间，所以 margin 垂直方向上有了可分配的空间。 4 再设置 margin 垂直方向上下为 auto ,即可实现垂直居中。(注意高度得设置)4. 动画属性：transform:就是 &#96;&#96;&#96;css #center &#123; position:absolute; left:50%; right:50%; transform: translate(-50%,-50%) &#x2F;&#x2F;其实就是因为刚开始，元素左顶点位于中心，所以此时让这个元素相对于自身往左移动50%，再往上移动50%，由于css动画是上负下正，和数学坐标是相反的。 &#125; CSS 动画rgba()和 opacity 之间的区别rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的 所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！）。 一句话总结就是 opacity(有 c(继承父元素透明度))，而这个 rgba 是不继承的，并且是一个函数。 rgba 和 opacity 动画的区别 transform 字面意思就是变形的意思，就是有 rotate()旋转，translate(x,y)平移联想”依赖动画实现水平垂直居中”。 还有一个属性就是：transform-origin: 变形的基点。 CSS3 动画和 js 动画之间的区别 第一点，就是 js 动画，没有兼容性问题，而 CSS3 有些浏览器不支持 js 动画经常涉及操作 dom 可能会导致这个，重绘重流的问题。 由于这个 js 是单线程，可能会阻塞其它任务的执行。 而 CSS 动画，由于不是 js 所以无法绑定事件，较为复杂的动画做不了。 CSS 选择器（选择元素添加样式） css 选择器参考链接。 1：类名选择器 id 选择器 标签选择器 属性选择器： input :[ type=’text’] 通配符： * 伪类选择器； a: nth-child() link : hover。 margin 负值 这里联想一个图，就是，有上下左右四个边距，然后，向上和左，就是，拖拽，对于下和右就是相应位置将不占高和宽。 。 margin 负值的链接。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Cookie Redis Session","slug":"cookie session redis","date":"2021-01-20T04:20:43.000Z","updated":"2021-03-15T07:57:12.327Z","comments":true,"path":"2021/01/20/cookie session redis/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/20/cookie%20session%20redis/","excerpt":"","text":"session 怎么实现登录的 cookie 如何来实现登录校验：就是每次用户登录过后服务端为用户设置一个 cookie：并且是一个随机数，不是真实的用户信息。这个 cookie 要设置过期时间以及设置这个 Http:Only 字段 用户的 cookie 值所对应的真实信息，都存储在服务器端的 session 里， 就是登录后下次请求，带上 cookie 做身份验证，服务器在 session 中找对应关系，能找到对应的信息，就通过并返回数据。 node.js 是多进程，进程之间的内存无法共享，所以需要用到这个 Redis,就是将所有 session，存储到 Redis 中。 那么 session 有什么问题 内存存储到 node.js 进程里，那么内存有限2：由于真实的环境下是用多个进程所以，你第一次存第一个进程，第二次登录想找自己登录所对应的用户信息，就找不到，进程之间无法共享内存，每个进程都有自己独有的内存区域，但其内存又是有限的3：node.js 是多进程的，因为能够提升运行的效率Redis 就是来解决如何能够进程之间共享内存的问题：内存数据库是什么就是一种缓存上的一个数据库访问速度快，但内存小成本高Web server （类似于 node.js 的进程服务) 之前 session 是存在这上面的，然后之后二的话就是说。 存到 Redis 里这样不会占用 node.js 的一个内存空间，现在统一的把 session 放到了 Redis 中，这样就可以是实现了，内存共享。 那为什么用 Redis 存储 session，而不是用 MySQL，因为要频繁访问，性能要求高（内存更块），数据量更大一些.","categories":[{"name":"后端","slug":"后端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"TLS1.2","slug":"TLS1.2握手协议","date":"2021-01-18T14:12:00.000Z","updated":"2021-03-15T07:48:59.337Z","comments":true,"path":"2021/01/18/TLS1.2握手协议/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/18/TLS1.2%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"总括 以ECDH算法举例 我现在要和一个人互相诉说小秘密，但是此时彼此都不知道身份，现在我和一个人进行碰面，在咖啡厅里会面，那肯定先得打个招呼。 但是由于我不知道对方的真实身份，所以我得需要对方发一个证明，验证身份我确认了对方是对的人了。 然后我和对方都把自己的一些小秘密(客户和服务器依赖于ECDHE子算法，彼此通过两个随机数生成了pre-master 随机数) 都整理好进行交换， 这样我们都知道了对方的小秘密。互相成了好基友 但是之后由于大家都很忙，所以我们互加微信，但是为了能够保证彼此的信息，不会被人拦截，所以我需要，对信息加密,就用之前彼此交换的秘密作为加密信息，进行对称加密 打招呼 验证身份 密钥交换 加密阶段 1. 打招呼阶段 客户端发消息 四个个信息 client hello 自己所支持的密码套件 以及TLS协议的版本号 用于密钥交换的，client random 那服务器回消息 四个确认信息 server hello 确认使用客户端所支持的密码套件 以及TLS版本号 密钥交换的server random 2. 身份确认阶段 服务器 服务器向客户端发了证书，用自己的私钥进行加密 同时服务器向客户还发了一个server params 此时双方都具有了用于密钥交换的两个参数（client params ,server params) 客户端 客户用公钥进行解密，确认了对方的身份之后 回了一个client params 此时双方都具有了用于密钥交换的两个参数（client params ,server params) 3. 密钥交换 客户和服务器依赖于ECDHE子算法，彼此通过两个随机数生成了pre-master 随机数 彼此综合三个随机数，各自生成主密钥 master-secret 用于之后对称加密信息. 之后发出加密算法通知，并发出finish（将之前的信息摘要）这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验。 TLS1.3","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"TCP重难点知识","slug":"TCP重难点知识总结","date":"2021-01-17T01:12:00.000Z","updated":"2021-03-24T01:33:15.708Z","comments":true,"path":"2021/01/17/TCP重难点知识总结/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/17/TCP%E9%87%8D%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"TCP如何来理解 tcp 是面向流的 所谓的流就是说无”消息保护边界的”，这里通俗理解就是说接受方无法去界定这个消息的开始和结尾，而有消息保护边界就是说消息之间是独立的，因为消息与消息之间有边界。 过程 首先（先联想图）客户端向服务器发出序列号 SYN ，seq（随机发出一个序列号） 服务器收到后会基于客户端的序列号，发出一个 ACK 确认号。为了表示一个回礼，还需要发 Seq 客户端会再次对服务器的序列号产生一个确认。 为什么建立连接是三次，而不是两次。防止历史请求初始化 tcp 连接 反向验证两次为什么不行：如果只有两次，客户端这里对于服务器发来的报文，无法来判断这个报文是否有效（是否过期，是否超时）因为网路拥塞这样的事情很常见。 所以客户端这里没有足够的上下文来判断，是否是如期的请求。 此时从三次说，那为什么三次避免了这样的问题，当客户端收到服务器的请求的时候，客户端本身会存储自己所发出的序列号，所以可以依据所收到的 ack 来判断是否是如期的，如果是就正常连接。 但如果不是，那就发送 RST （有重置的意思）报文，来结束这个连接。 确认彼此的系列号 其实 tcp 能够实现可靠连接的本质其实是能够确认彼此的序列号，那你如果只有两次，只能单向确认，无法互相确认，所以需要三次。 防止（服务器）资源浪费 由于仅有两次，服务器是没有办法判断对方是否收到了正确的序号 客户端如果因为网路阻塞，发出了多个 SYN 信号，那客户端有可能收到，也有可能收不到，所以为了确保对方收到，服务器只能建立多个重复的 tcp 链接。极大的浪费资源。 TCP 四次挥手 首先看到四先想想哪四次，两对 FIN-ACK ，为什么一定要四次，就是说客户端向服务器先发 FIN 表示两个人关系淡了想分了，所以发出 FIN 终止报文。 服务区器先对终止报文发出确认 但服务器收到还可能对收到的信进行处理并发送，意味着此时不能立刻终止关系。 在处理完信息后再去发出 FIN，自身进入 closed 状态。 客户端收到信息后再次，向服务器发出一个 ACK,后它不会立刻进入到 closed 状态，它需要等待两个 MSL（最大报文生存时间）为什么是两个主要是因为网络时常会发生阻塞，对方没有收到一个 ACK,客户端会重发，那么重发之后一个来回就对应了两个 MSL。 补充：TIME——wait 等待过程，”timewait closewait”. TCP 流量控制知道滑动窗口不，客户端和服务端控制滑动窗口的过程是怎样的。 （此处联想 tcp 连接的一个过程）首先滑动窗口受限于接收方的接收能力大小，就是发送方每发送数据后，服务器就会去移动滑动窗口的指针，之后可用窗口会减小，并且会将当前可用窗口的大小发送给客户端，用来控制发送方发送的数据量以达到，流量控制。 讲述思路： 首先想到滑动窗口首先联想接收方有一个滑动窗口，也就是说这个主要是和接收方有关，防止对方发送的数据超出了接收方的数据。 发送窗口和接收窗口分别由哪些构成 发送窗口：由发送想到了已发送到并得到确认的字段区域，那有得到确认的自然还有没有接收到确认的，可用窗口，那由于自身肯定还有好多数据好多话想告诉接收方所以自然还会有许多数据等待发送，但是这个会超出对方的接收范围。也就 是不可用窗口。（两个发送，可不可以）4 个 接收方窗口：已经接受到的数据并确认，理解有一个误区就是说接收方没有接收到数据但是没有得到确认的，发送方有是因为它自己是发送数据的，接收到的 ack 是有可能阻塞的，未确认，接收方不考虑这个，只管接收就好。还有未接收到，并是可接受范围内，未接收但是，超出了可用窗口大小的区域。（三个） 那你知道滑动窗口和拥塞窗口有什么区别不 由拥塞想到了网络拥塞，也就是说主要应用于解决网络拥塞问题的，主要由发送方控制，防止它发多了导致了网络拥塞。 而滑动窗口主要是因为解决防止发送方数据量超过了接收方的能力，也就是说其大小取决于接收方。 如果对方问到这个 tcp 流量控制我该怎么回答 流量控制依赖于滑动窗口来控制发送方发送的速率不要太快 你怎么理解这个窗口其实就是一个操作系统的一个缓冲区，只有收到确认才能将已经发送的数据进行发送。 所谓的流量控制其实就是面试以服务端发送举例子（此时假定发送窗口可接收窗口都不变的情况），客户端接收做例子，这里我概括说就是，每当服务器发送完数据后，相应的可用窗口大小就会减少，相对应的指针也会发送变化，就是 snd.next 指向的是可用窗口大小的头指针，右移，当收到了对方的确认后，自生的 snd.una 也会右移，那么此时可用窗口大小自然增大。 此时接收方再接收到信息后 rsv.next,也会发送移动，如果发送方的数据超过了其可用窗口就会导致窗口关闭也就是说起到了流量控制。在接收到接收方的确认后才可以据悉的发送数据。 实际上如果应用层没有及时的读取缓存区里的数据就会导致，每次接收方接收到数据后，其接收窗口大小会变得更小，并且会将这个大小以 window 字段来告诉，发送方来达到流量控制，以此控制发送方的速率。 但是窗口大小其实是和操作系统的缓冲区是有关的，如果先减少了接收缓存区，又收缩了窗口，最终没有多余接收缓存，可以接收数据，就会导致丢包，那为了解决这个问题，就是先来收缩窗口，再去减少接收缓存。**?** 窗口局面就是说如果说在窗口关闭后，应用应用进程如果没有及时读取缓冲区里的数据会导致窗口收缩， 那么在窗口关闭后应用进程及时读取消息，就会恢复其接收窗口大小，并且会通知发送方以 window 字段，但是这里有一个问题就是，如果这个消息丢失了，就会导致，死锁现象。 坚持定时器，就是一旦接收方窗口大小变为 0 就会启动，并每隔一段时间来进行探测报文探测对方目前可用窗口大小，这样就可以来避免死锁了。 拥塞控制（联想折线上升图） 首先来复盘一下自己的知识点，就是首先由拥塞想到了为什么拥塞窗口也就是说 crwd, 那么也就是说所谓的拥塞窗口主要是来解决网络拥塞的。 那么首先达到慢启动阶段，以指数增加。[慢启动为什么是指数增加] 之后到达了门限值，之后进入了拥塞避免阶段，每接收到一个 ack 就拥塞窗口加拥塞窗口分之一。线性增加 但是还是会拥塞，先有超时重传，门限值减半，拥塞窗口初始化为 1 还有一种就是快重传会接收到三个重复的 ack，cwnd 减半，然后门限值为拥塞窗口一半，到达快恢复后，其拥塞窗口在此基础上加三（三个重复的 ack）。 粘包拆包问题tcp 粘包， 由于 tcp 无消息保护边界，（个人理解就是不知道消息从哪里开始，也不知道消息从哪里结束）需要在接收端来处理消息边界问题，这也就是说粘包，拆包问题。 什么是粘包，就是说有可能两个信息包，粘在了一起 有些包被拆成几块因为大于了 MSS,所以需要拆包，，然后与其它包粘在一起。 为什么会出现这个奇怪的现象 对于接受方就是，接受数据到缓存的速率大于了应用进程读取数据的速率，就会导致多个包粘连在一起。 发送方的 Nagel 算法。导致出现了在接收到一个确认后，收集多个分组数据再去发送。 怎么解决这个问题 发送方 去关闭 nagel 算法。 由于接收方不清楚，一个完整消息的大小，所以发送端会给数据包，添加一个包首部，这个首部，会包含数据包的长度，这样接收方通过首部消息就可以知道了类似于有了消息边界。 发送端将每个数据包大小固定，这样接收方就可以知道这个了。 也可以在数据包之间设置边界，如添加特殊的符号，接收方就可以清楚一个完整数据包的大小了。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTP缓存","slug":"Http缓存","date":"2021-01-15T14:20:00.000Z","updated":"2021-03-24T01:33:47.702Z","comments":true,"path":"2021/01/15/Http缓存/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/15/Http%E7%BC%93%E5%AD%98/","excerpt":"","text":"Http缓存为什么要有缓存如果你每一次的请求都让服务器去重新发送资源 这无疑是非常的低效的 如果说能够做到把一些重复申请的资源存放在缓存里而服务器不必每次都返回资源 这样能够极大的提升用户访问资源的效率 那我能够缓存哪些资源静态资源 img css js 哪些我不能缓存 html 为什么-因为html的结构可能会随着需求的变更而变更 流程强缓存 首次浏览器向服务器发出http请求 服务器返回资源，同时响应头部还包含一个cache-control里面是资源失效的时间（此时返回的同时将资源缓存到本地） 此时浏览器将资源与缓存的标识（1.LastModified,2.Etag）存放在本地缓存里 第二次请求资源 直接会访问本地的资源/同时要来判断资源是否过期 依据是什么cache-control，与客户端自己的时间进行对比 没有过期 本地缓存直接返回资源 过期了 协商缓存（对比缓存） 这里补充一下Etag 如果信息更新Etag也会去更新 它是根据内容来更新的 只要内容不变 Etag就不变 你先搞清楚它的意义 它就是用来对比服务器的资源和本地资源是否一致-从而确定是否有必要重新返回资源 此时携带着之前服务器所返回的缓存标识（Etag)发送请求给服务器 此时服务器再根据自己最新的Etag与客户端发来的Etag做对比 一致直接返回304给客户端 意思就是资源没有更新–可以继续访问原有本地缓存 不一致 直接返回新的资源给客户端","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"V8引擎基础总结","slug":"V8引擎","date":"2021-01-01T14:22:00.000Z","updated":"2021-03-04T15:33:50.599Z","comments":true,"path":"2021/01/01/V8引擎/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2021/01/01/V8%E5%BC%95%E6%93%8E/","excerpt":"","text":"V8引擎如何来执行一段js代码首先你想想，v8想要来执行一段代码，首先你得有一个初始环境吧，基础环境 全局执行上下文 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 全局作用域 里面有全局变量，全局函数 想来存储对象，不得需要创建存储的空间吗/堆 —栈 事件循环系统 web api 有了基础环境就可以来执行代码了 为了能够让v8引擎识别代码，需要将其结构化 AST 转为/字节码中间代码 交给解释器来执行 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 作用域 监控器–如果监控发现解释器在重复执行某段代码 会将其转为热点代码 交给编译器编译为二进制机器码–在进行优化 下次再执行解释器优先解释执行优化过后的二进制机器码代码 闭包V8执行代码过程 编译 将代码转为中间代码 AST树 特点 惰性解析 v8引擎处于对内存占用，用户体验的角度，其实并不是将所有的代码，都转为中间代码/或是机器码 具体就是遇到函数声明不会为函数内部的代码转为字节码/AST 依赖闭包来实现 执行阶段 三大特性 允许函数嵌套函数 允许内部函数访问外部函数的变量（依赖作用域链） 正是由于这个特性，在惰性解析阶段 ,由于并不清楚内部函数是否引用了外部函数的变量，从而导致这个变量无法被回收 为了解决这个问题，预解析器 检查函数的内部是否有错 判断函数内部是否存在引用了自由变量 会将这个变量复制到堆中，这样，即便父函数执行完毕后，变量被销毁，子函数依然可以在堆中找到我所引用的变量 函数可以作为返回值（函数是一等公民）所以可以实现类似基本数据类型的事情 编译流水线·宿主环境 浏览器为v8执行javascript提供了必要条件 node.js也是v8的宿主环境 存储空间 栈空间 存储函数的/这个是不是所谓的函数调用栈 也就是说每调用一次函数 就将其推入栈中，由于栈的空间是连续的，并且是有限的，所以随着不断的递归调用，栈会溢出 v8引擎首先会将全局执行上下文推入栈中，之后调用函数会再次将函数执行上下文推入栈中 堆空间 基础数据类型 那现在有了存储空间的创建，还有全局执行上下文，和函数上下文还缺点什么，还缺宿主环境提供的主线程 原因在于v8执行代码其实是依赖于宿主环境提供的主线程 主线程会循环的调用，消息队列里的任务 垃圾回收机制当v8引擎判断某个变量不再需要的时候会进行处理分类 为什么要分类 为了针对不同对象的生存周期，来灵活处理 堆？为什么不是栈 新生代 内存空间很快会被回收 老生代 能到老说明什么，生存周期久 主垃圾回收器 算法 标记–清除算法 标记–整理 步骤 V8引擎会来判断对象是否可抵达 可抵达 可以被清除 不可抵达 不可以被清除 但在清除之前，将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个久是让内存空间尽可能的连续 最后才去清除所有可抵达的对象 副垃圾回收器 堆里 新生代 存储空间 空闲区域 老生代 步骤 当新生代的对象里的存储空间，存储数据，并且要被删除之前会复制存活的活动对象，给空闲区，并存到连续的空间内，之后存储空间和空闲区域，进行调换 如何解决异步回调的问题promisefetchgenerater 为什么有了promise 还要有generater 主要是因为处理逻辑过于复杂的话，会充斥着大量的then()方法，依然不便理解 想来利用同步的方式来书写异步的代码 函数暂停执行 遇到异步执行任务，暂停整个函数的执行 函数恢复执行 当得到了某个异步任务请求的数据，后再恢复函数的执行 弊端就是依然需要，co函数，繁琐 async/await 用同步的形式，书写异步的代码 底层逻辑：微任务和协程应用 async 异步执行并隐式返回promsie 先来通俗的理解，当用了async后，遇到await 会等await后的函数，也就是说async 函数，会暂停执行，在合适的时机来返回 那么问题来了–何时恢复其执行 await等待的类型 普通表达式 V8引擎会自动将其包装为已经成功的promise对象 promise 会暂停async 声明的函数，然后等待promsie对象的状态转变为fullfiled/rejected才会恢复函数执行 UI线程消息队列 当通过鼠标，键盘等所触发的事件，会推入到ui线程里 由主线程来不断取出，再执行那怎么来理解settimeout里回调函数的执行 就是ui线程遇到settimeout会将里面的回调，包装为事件，推入宏任务队列里面 宏/微任务队列 宏任务 微任务 主线程 调用栈 先推入全局执行上下文 每调用一个函数就将其推入栈中 每执行完一个函数之后，就将其出栈 这里如果遇到没有终止条件的递归函数，由于调用栈空间有限里面会存在过多的函数执行上下文导致栈溢出 消息队列 来理解一下为什么会有微任务，它的出现解决了什么问题 主要解决了宏任务执行时机不可控的问题 回调函数同步回调 就是在以（回调函数为参数的函数）执行函数内部，去执行回调函数的 异步回调 就是在在其它位置/其它时间点来调用回调函数，settimeout 是将其内部的回调函数，封装为一个宏任务，由主线程某一时刻，来取出并执行的","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"异步理解","slug":"异步","date":"2020-12-29T12:22:00.000Z","updated":"2021-03-04T15:32:51.561Z","comments":true,"path":"2020/12/29/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/29/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending new/创建 一个promise后的状态 fulfilled 调用promise.resolve()的方法后 rejected 异步任务出错/或是抛出异常后//但是如果仅仅是return 了一个错误对象，也是不行的 调用promise.reject() 不同状态所触发的方法 then() 首先当promise对象为fullfiled时会触发 里面只能接收一个函数，其它类型一律无视 并且会返回一个新的fullfiled(一般情况下，如果throw了一个错误)promise对象 这也解答了自己一个疑惑就是说，为什么then可以链式来调用，不是状态只能变一次吗，其实是因为又新建了一个新的promise对象 catch() 当状态为rejected时触发 返回了一个具有fullfiled状态的promise对象 finally 无论什么状态，最终都会执行的函数 谨记一点就是 promise的状态的改变是不可逆的 一旦成为fullfilled状态，或是rejected状态 即便是同状态的改变也不可以 核心 状态仅能改变一次 再具体一点就是说，一旦状态变了，后续,resolve(),reject()方法全部失效 有哪些方法 resolve(value) 成功 Subtopic value是一个带有then()方法的对象 由then()方法所返回状态来决定 从这可以看出来，then()方法返回的并不一定是成功的状态 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务 它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 那么为什么要有异步有些网络请求实在是太耗费时间了，如果不引入异步机制的话会浪费时间，用同步的话，只要第一个任务没完成后面的任务全部阻塞了哪些属于异步任务settimeout()dom事件AJAX/AXIOS请求setinterval()回调函数 先明确一下什么是回调函数 就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数 那它和异步有什么关系 回调函数能够获得异步任务的结果","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"图片懒加载","slug":"图片懒加载","date":"2020-12-27T14:22:00.000Z","updated":"2021-03-15T08:26:09.581Z","comments":true,"path":"2020/12/27/图片懒加载/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/27/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"图片懒加载 首先所谓的图片懒加载其实就是当触发滚动事件的时候，判断当前元素上边距离视区域的上边框具有多少距离，如果说刚好小于等于视口高度，那就是遍历每一个元素，然后获取每一个元素上的 data-src 里得真实的 src,去赋值给每一个元素的 src，并且为了避免已经加载过的元素，再次遍历就设置 count 进行计数， 问题： 自己经常忘记，计算网页视口的高度，主要是需要，先计算这个当前元素距离视口上边框的距离，和视口高度比较，只有小于等于的时候这个循环添加真实 src 才有意义。 1234567891011121314151617181920&#x2F;&#x2F; &lt;img src&#x3D;&#39;&#39; data-src&#x3D;&#39;&#x2F;img1&#39;&gt;&lt;&#x2F;img&gt;&#x2F;&#x2F;&lt;img src&#x3D;&#39;&#39; data-src&#x3D;&#39;&#x2F;img2&#39;&gt;&lt;&#x2F;img&gt;&#x2F;&#x2F;&lt;img src&#x3D;&#39;&#39; data-src&#x3D;&#39;&#x2F;img3&#39;&gt;&lt;&#x2F;img&gt;let imgs &#x3D; document.body.getElementsByTagName(&#39;img&#39;)&#x2F;&#x2F;集合let viewheight &#x3D; window.innerHeight&#x2F;&#x2F; 窗口的高度let count &#x3D; 0function lazyout() &#123; let distance &#x3D; viewheight - getBoundingClientrect().top&#x2F;&#x2F;api获取当前元素的上边框到达窗口上边框的距离 if (distance &gt;&#x3D; 0) &#123; for (let i &#x3D; count; i &lt; imgs.length; i++) &#123; let attr &#x3D; imgs[i].getAttribute(&#39;data-src&#39;)&#x2F;&#x2F;获取每一个元素里的data-src然后，再赋值给这个元素里的src. imgs[i].src &#x3D; attr count++&#x2F;&#x2F;避免重复循环已经加载过的元素 &#125; &#125;&#125;document.addEventListener(&#39;scroll&#39;, lazyout)&#x2F;&#x2F;监听这个滚动事件然后再去触发这个懒加载。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTPS基础","slug":"HTTPS","date":"2020-12-25T14:22:00.000Z","updated":"2021-03-15T07:50:08.155Z","comments":true,"path":"2020/12/25/HTTPS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/25/HTTPS/","excerpt":"","text":"HTTPS复盘HTTPS对称加密 其实就是说用同一个经过交换的公钥来加密信息 弊端：交换过程容易被中间人所攻击 非对称加密 其实就是用公钥加密，私钥解密 服务器（公钥a-私钥a)先将公钥a发给客户端，客户端拿到公钥a后加密自己生成一个随机数，然后再发给服务器，服务器再拿私钥a来解密公钥a所加密的随机数 之后再去用这个随机数充当之后对称加密的公钥 TLS握手阶段/ECDHE算法 一阶段 客户端 client hello 支持的TLS协议版本号 支持的密码套件 Client Random 服务器 server random 确认TLS协议版本号 确认选取某个密码套件 Server Random 二阶段 此时服务器为了能够验证自己的身份,向客户端发送证书（里面包含着服务器给客户端所发的公钥） 以ECDHE举例：之后服务器还会发给客户端一个Server params 用于密钥交换算法 密钥交换阶段 客户端 此时收到证书，先验签证明是如期的通信方后，取出证书里的公钥，同时生成一个Client Params,发给服务器，此时双方基于ECDHE算法（client params server params )生成Pre-master 对称加密的过程 客户端 此时拥有三个随机数 client random server random pre-master 服务器 同理也生成了一个Master Secret 之后双方拿这个Master随机数来加密finished 信息代表握手结束，之后就拿这个Master来当对称密钥，来进行之后的对称加密 默认端口443不可否认性TLS密钥交换算法签名算法对称加密算法摘要算法身份验证子主题完整性由于黑客可能窃取足够多的密文，并改造，重组再发给服务器，此时如果无法保证信息的完整性，服务器只能全盘接收依据其响应反推密文，所以此时要来保证信息的完整性摘要算法 单向将密文压缩为独一无二的摘要 SHA-2 常用算法 特点 单向性 无法由摘要反推密文 雪崩效应 微小的改变都会造成极大的改变，避免黑客篡改信息 具体应用就是说 此时客户端发送用会话密钥加密的消息以及对应的摘要 服务器接收并用会话密钥解密后，拿到信息，自己再用SHA-2算法生成摘要来比对对方的摘要，无变动说明没有改动 机密性对称加密 用同一个公钥加密和解密 常用算法 chacha20 AES 分组模式 将密钥转化为密文 密钥加密明文转换为密文 非对称加密 通俗来讲网站保管私钥，网上分发公钥 公钥加密，私钥解密 单向性 解决了对称加密中密钥交换的安全性 常用算法 RSA 基于整数分解的数学难题 ECC 基于椭圆曲线离散对数 ECDHE子算法 用于密钥交换 弊端就是由于基于各种数学难题，所以运算速度极慢 所以HTTPS采用混合加密https优化 由于硬件升级成本高，并且前端也做不了，主要考虑协议上的优化。 首先尽量选取tls1.3因为其往返时间，减半将hello信息和椭圆曲线及公钥也一并进行了交换，所以快，如果只能1.2就用ECDH椭圆曲线算法，最好用x25519曲线。 此处联想身份验证时所发的证书，肯定越小越好，所以用椭圆曲线，比RSA更好，因为其位数更小 sessionID 首先就是由于每次建立https连接都要重新进行握手然后算主密钥，太繁琐，所以每次tls握手结束后将主密钥存储到内存里，双方各生成与之对应的sessionid，相当于一个键值对，所以的话就是说下次握手时将id带上，然后服务器在内存中找到主密钥，就可以直接进行加密信息了。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"深拷贝","slug":"深拷贝","date":"2020-12-25T14:14:00.000Z","updated":"2021-03-15T08:25:47.276Z","comments":true,"path":"2020/12/25/深拷贝/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"思想 复盘第一次判断传入参数是不是一个对象造成了混乱，应该是判断不是一个数组或对象，并且对象为空，我当时还用了 type of 判断空，其实不对，应该是直接参数等于 Null 就行，typeof 还得为一个 object ,之后用 instance of 来判断这个元素是不是这个数组，对象，做对应的处理，并且这里要用到这个递归，为什么，因为对象里面有可能去嵌套一个对象， 那么递归式，先去处理第一层的逻辑，就是直接赋值，如果还有值，那就重复逻辑，给它套一个递归，这样它就可以去继续判断里面的对象。 我还卡在了 这个 for in 循环上其实这个不管是数组，还是对象都可以用到这个，并且遍历的是键，也就是索引值，并且要配合这个 hasOwnPropoty 来剔除从原型链上继承的属性。 12345678910111213141516171819202122232425262728a &#x3D; &#123; a: 1, b: &#123; a: 1 &#125;&#125;function deepclone(obj) &#123; if (obj !&#x3D;&#x3D; null &amp;&amp; typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123; throw new TypeError(&#39;必须是数组或对象，并且不能为空&#39;) &#125; let res &#x3D; [] if (obj instanceof Array) &#123; res &#x3D; [] &#125; else &#123; res &#x3D; &#123;&#125; &#125; for (key in obj) &#123; if (obj.hasOwnPropoty(obj[key])) &#123; continue &#125; res[key] &#x3D; deepclone(obj[key]) &#x2F;&#x2F;对于这个递归的逻辑还是不清楚 &#125; return res&#125; 1234567891011121314151617181920212223242526272829303132333435363738function deepCopy(obj, cache &#x3D; new WeakMap()) &#123; if (!obj instanceof Object) return obj &#x2F;&#x2F; 防止循环引用 if (cache.get(obj)) return cache.get(obj) &#x2F;&#x2F; 支持函数 if (obj instanceof Function) &#123; return function () &#123; obj.apply(this, arguments) &#125; &#125; &#x2F;&#x2F; 支持日期 if (obj instanceof Date) return new Date(obj) &#x2F;&#x2F; 支持正则对象 if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags) &#x2F;&#x2F; 还可以增加其他对象，比如：Map, Set等，根据情况判断增加即可，面试点到为止就可以了 &#x2F;&#x2F; 数组是 key 为数字素银的特殊对象 const res &#x3D; Array.isArray(obj) ? [] : &#123;&#125; &#x2F;&#x2F; 缓存 copy 的对象，用于处理循环引用的情况 cache.set(obj, res) Object.keys(obj).forEach((key) &#x3D;&gt; &#123; if (obj[key] instanceof Object) &#123; res[key] &#x3D; deepCopy(obj[key], cache) &#125; else &#123; res[key] &#x3D; obj[key] &#125; &#125;); return res&#125;&#x2F;&#x2F; 测试 const source &#x3D; &#123; name: &#39;Jack&#39;, meta: &#123; age: 12, birth: new Date(&#39;1997-10-10&#39;), ary: [1, 2, &#123; a: 1 &#125;], say() &#123; console.log(&#39;Hello&#39;); &#125; &#125;&#125;source.source &#x3D; sourceconst newObj &#x3D; deepCopy(source)console.log(newObj.meta.ary[2] &#x3D;&#x3D;&#x3D; source.meta.ary[2]);","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"TCP简要总结","slug":"TCP","date":"2020-12-23T14:12:00.000Z","updated":"2021-03-15T07:49:06.211Z","comments":true,"path":"2020/12/23/TCP/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/23/TCP/","excerpt":"","text":"TCP这一次首先复习一下TCP重传机制为什么TCP会重传呢 TCP建立连接的过程如果这个过程如果有丢包那么就会触发重传机制 超时重传 就是TCP内部有一个机制会设定一个时间（时延）这个时间大概略大于，tcp报文往返时间，这个时间的设置不能太短，如果太短那报文还没来的及发回来就误认为包丢了，导致重传，但是也不能设置的太长，这个会造成网络资源浪费（为什么会造成资源浪费我来解释一下：就是说如果时间设置太长了，此时真的发生丢包了，那客户端等很久之后才重发，那不是很浪费网路资源嘛对吧； 快速重传 为什么已经有了超时重传：还要有快速重传 其实是这样，就是说，由于超时重传，是要等一段时间才重传，其实效率并不是很高，所以网络设计们采取了快速重传机制这样效率更高 什么时候会触发快速重传机制，比如此时发送方发送了三个数据包（1，2，3），其中2没有发送出去，接收方只发出基于第一个数据包的确认号，并且重复了三次（不包含第一次的确认，再此基础上，再来三次确认）这个确认号，就是告诉发送方，2这个数据包丢失了，需要对方重新发送，于是触发了发送方的快速重传机制，发送方会重新传送2这个丢失数据包 特点 接受方会重复发送丢失包的确认号 缺点 这里存在一个问题就是，发送方是依据所收到的确认号，来确认接受方是否收到了数据，但是此时发送方只接受到了丢失包的确认号，它也不知道之后的数据包到底发送成功没；————于是Sack就是来解决这个问题的 SACK 这里我通俗来讲一下，就是说为了能够让对方知道自己到底具体传哪些丢失的数据包，每次服务器发来的确认号，还会带上服务器已收到的最大 连续的包的序列号 滑动窗口为什么要有滑动窗口 为了提升网络传输效率 原因在于tcp为了能够实现可靠信息的传输：为每一个数据包都进行确认，那么这就导致了，数据包往返时间越长，网路通信效率就会大幅度的降低（不是很理解网络吞吐量），所以才引用到了窗口 怎么做的：就是为tcp报文设立一个滑动窗口，这个滑动窗口的大小由服务器决定/并且，是无需等待对方的确认，而可以继续发送的数据包 发送窗口 已收到确认的序列号 已经发送但未收到确认的序列号（这个窗口的尺寸大小是服务器能接受的） 还有一段未发送，但在接收方能力范围内的数据段（又称可用窗口的大小）（未发送但是可发送的包） 超出了服务器所能接受的序列号 接收方滑动窗口 已收到数据，并且已经确认的数据段 未收到数据但是可以接受的窗口大小 未收到数据但是无法确认的数据段 那有一个问题就是如果中途其中一个确认号丢失了，怎么办 滑动窗口中的序列号是有序的，这也就意味着确认号也是有序的，只要缺失的那个序列号的确认号之后的确认号得到了确认，那么就是一种累计确认，只要某个确认号确认后默认之前的所有序列号都得到了确认（这里我对于序列号不是很理解） 滑动窗口是怎么个滑动法 就是服务器发来确认号后，发送方的滑动窗口相应的就会滑动和确认号序列相同的距离，意味着可用窗口增加了 补充：滑动窗口大小的含义：指的是发送方不必等待对方的确认，可以发送的最大报文段 流量控制就是来控制发送方发送数据的速率，防止超出接收方处理接收数据的能力依赖于滑动窗口 意思就是通过告知发送方自己的接收窗口大小rwnd来，控制发送方的数据–从而实现了流量控制 那所谓的窗口是什么：就是接收方最大所能处理的数据量窗口关闭 主要就是在接收方发送给发送方自己最新的接收窗口大小的时候，发生了丢失–tcp的可靠传输没有对窗口大小的消息产生作用 双方都在等待对方 拥塞控制拥塞控制主要是避免发送方不断的发送数据而导致网络拥塞那为了避免拥塞，需要客户端维护一个拥塞窗口（CWND）ssthresh//阈值有哪些算法 慢开始 就是一开始每当收到一个ack，其cwnd加一个，第二轮收到2个，cwnd就为2，第三轮次收到4个ack，cwnd为4,这样呈现了指数增加 拥塞避免 但是随着客户端发送数据数量的增加 一定会到达阈值 进入拥塞避免后每收到一个确认，cwnd只加1/cwnd，比如当前收到了8个确认，一个加1/8,这次拥塞窗口仅加了一次，之后就是线性增长了 拥塞发生 你即便是再怎么避免，还是会导致网络拥塞 超时重传 进入拥塞避免算法 但是这里有一个问题就是说：每次一进入拥塞避免，拥塞窗口，直接就初始化为1 就算网络不拥堵，但是会卡顿，因为所能发送的数据包骤减 此时客户端认为其实网络情况也没有那么糟糕 ssthresh=cwnd/2 初始化cwnd=1 快重传 cwnd/2 sshred=cwnd/2 快恢复 触发快重传后，紧接着执行 cwnd=ssthred+3(ack报文） 很明显拥塞窗口已经大于阈值了：之后再次进入线性拥塞避免算法","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"ES6基础","slug":"es6","date":"2020-12-15T14:20:00.000Z","updated":"2021-03-22T13:29:47.943Z","comments":true,"path":"2020/12/15/es6/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/15/es6/","excerpt":"","text":"es6promise/generator/async/await箭头函数是什么 function的一种简化 何时用 简化函数，凡是用到函数的时候就可以用 怎么用 无参数 &lt;ol&gt;&lt;li&gt;（）=&gt;{&nbsp; &nbsp;}&lt;br&gt;&lt;/li&gt;&lt;/ol&gt; 有多个参数时 const&nbsp; fun=(a,b,c)=&gt;{&nbsp; return 函数体} 注意要得到函数返回值别把return忘记 正则表达式什么是 限制用户所输入的信息，的表达式 什么时候用 表单验证 用户名输入的时候 子主题 对于密码验证的时候 怎么用 起止符 ^ 开始符号 &amp;结束符 多选一符号 [ ] 组合符号 ^[^A-Z0-9${2,3} ] 后面花括号代表的是从前面选2-3个元素； 作用域块级作用域 const 这个和let的最大的区别就是，const不可以先只声明 为什么 const所定义的是一个定值，如果你只声明不赋值，如何做到是一个定值，感觉有点勉强 let Subtopic 它首先解决了var变量提升的问题 它怎么解决这个问题的，将全局执行上下文的创建阶段和执行阶段时机同步了所以不会再出现变量提升的问题 它还解决了，var没有作用域的问题 由块级作用域，引发了一个问题就是暂时性死区 什么时候会引发暂时性死区 条件 如果在一个块级作用域里存在let,那么此时let所处的作用域就会锁死 一旦在变量let声明前,去使用就会为undefined 那我什么时候能用，只有到声明后才可以去使用let/或const所声明的变量 那具体暂时性死区是什么 其实就是let/const声明前的代码区域（在块级作用域中） var 没有块级作用域 那如果没有块级作用域会引发哪些问题 在函数中用var声明的变量，函数外部可以访问，这个就很危险 也会引发变量提升的问题 根据你在声明变量的时候，会出现执行上下文，而创建上下文的创建与执行阶段是不同步的所以造成了变量提升 this指向指向谁 在函数 的内部， . . .实现对对象的深拷贝将数组转为由逗号隔开的序列，同时又可以实现拷贝传递形参时用 如果你并不知道参数有几个的时候,就是apply用到了，因为你也不知道调用函数的时候到底传递了几个参数。 解构怎么用 需要从一些对象（也可解构多层嵌套对象） 说人话 获取对象里的值 根据对象里的键来获取值 更高端大气怎样将类数组转为真正的数组Array.from(类数组)除过es6以外还有什么方法 Array.prototype.slice( ).call(类数组） 这个不理解 Map（）它解决了什么问题 专门用来存储键值对的 什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构那它有哪些方法 set(键，值） 这个返回的是新的map数据结构，包含有新的设置的键值对 has(键） 返回值为布尔值 目的是为了判断是否存在当前键//这个主要判断是否有对应的键 delete(键) 删除键所对应的键值对 get(键） 这个是在获取键所对应的值 这个在力扣第一题中用到它了 Set()一旦题目中涉及集合立刻想到set 特点就是，一旦题目提到有序，无重复元素，立刻反应Set() Set做了哪些事情 给定一个数组 返回一个没有重复序列的集合 能做到什么 数组去重 首先通过，[… new Set(arry)] 但是我对于这个有一些问题就是，首先通过…元素是否意思是将set数据结构转为数组，那如果已经是数组了为什么要在加上数组字面量不理解","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"LRU","slug":"LRU缓存机制","date":"2020-12-12T13:48:45.000Z","updated":"2021-03-06T09:08:34.634Z","comments":true,"path":"2020/12/12/LRU缓存机制/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/12/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"思路1. 浏览器 LRU 缓存策略 其实这个就是当输入网址访问时先会去本地缓存查看是否有我想要的数据，如果有直接用本地缓存的数据目的就是降低用户访问的时间 那么这里有一个问题就是，本地缓存总有满的一天，那么删哪些 核心： 删最近最少使用的—可以理解为，正是因为最少被使用，所以才该删 2. vue Keep-alive目的： 用于组件的缓存 具体怎么做的： 就是 keep-alive 有一个 max 属性，一旦缓存的组件数大于了 max 就开始使用 LRU 算法 cache 保存着组件实例，以及所对应的 key 值，然后就是还有一个 keys 数组存储着每一个所缓存组件的 key 值 当用到了某个组件，会先看一下 cache 里面是否有对应组件： 如果有了就将相应的 key 值从 keys 中删除并移动到最后一个元素：其实就是在模拟最近最少算法：头元素肯定是少使用的，放末尾的意思自然是最近就使用的； 当组件数》max 后，删 keys[0] 元素。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"相交链表","slug":"相交链表","date":"2020-12-01T14:22:00.000Z","updated":"2021-03-04T15:32:48.988Z","comments":true,"path":"2020/12/01/相交链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"160. 相交链表。反思 首先这个题的思路就是来联想一下这个相交节点，为什么要用双指针，就是说 a+b+c=b+1+c 也就是说我，都同时开始且路程相同，那么一定会在相交节点，相遇； 因此思路就是只要我能够判断当前的节点是否为空，如果为空了，那就将其接到下一个链表的头节点，如果不为空的话，那就去继续遍历。 自己的不足在于三元表达式不够熟练，就是自己，变量= 条件 ？ a: b ;也就是说只要条件满足执行 a 结果，不满足就执行 b 结果。 12345678910var getIntersectionNode = function(headA, headB) &#123; if(!headA||!headB)&#123;return null&#125; let p1=headA let p2=headB while(p1!==p2)&#123; p1= p1===null? headB:p1.next p2= p2 ===null?headA:p2.next &#125; return p2&#125;; mermaid 注意： 首先这个题只要求节点相同，没有说这个节点的值问题； 其次判断的条件就是这个有一个为空，必然没有相交的节点所以直接，就返回为空就好","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"闭包","slug":"biba","date":"2020-12-01T13:48:45.000Z","updated":"2021-03-05T15:17:35.773Z","comments":true,"path":"2020/12/01/biba/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/biba/","excerpt":"","text":"闭包体系切入点词法作用域 首先我需要从作用域的底层机制说起，首先在 V8 引擎中是有编译阶段的，这里叙述”js 执行代码过程”&gt; V8 引擎如何执行一段代码 编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于混合编译执行，JIT，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率。 这里还有一点就是此时引擎会在当前的作用域去寻找有没有所声明的变量，如果有那就忽略它，这也是为什么，var 可以重复声明的本质原因，如果没有的话就将这个变量存放在当前作用域，赋值阶段。 如何来叙述闭包 切入点词法作用域，那么词法作用域是怎样生成的（此时联想作用域里面有声明了一个变量），那么在编译阶段首先会来判断，当前的作用域有没有这个变量，有了就忽略，继续，没有就直接将变量放置当前作用域内并赋值 undefined. 那你不能光找到它，还得赋值，在当前作用域能找到直接赋值，没找到就不断向外部作用域找形成作用域链。 （谈到作用域本质就联想一个调用栈，里面压入了全局执行上下文，和函数执行上下文））作用域的本质到底是什么，从表层意思来讲，它是一套规则，存放相应变量的规则，从本质上来讲，它是当前所处执行上下文，从这一点可以明白，为什么闭包中，可以从内部访问外部的变量，而外部无法访问内部的变量，全局执行上下文首先会推入调用栈中，之后每当调用一个函数，就会将函数上下文推入栈中，所以即便调用栈中，栈顶执行上下文，执行完毕后出栈，但是内部执行上下文依然可以通过，作用域链来访问，但由于栈顶执行上下文出栈了作用域链也被销毁了，所以无法访问调用栈中上下文的变量。 作用域链也被销毁了，所以无法访问调用栈中上下文的变量。 补充词法作用域 所谓词法作用域本质就是，作用域的形成是在你所定义的位置，而不是你所调用的位置，这一点区别于动态作用域，它是在你所调用的时候，而不是你所定义的位置。 闭包应用。 var a = []; for(let i = 0;i&lt;10;i++)&#123; a[i]=function()&#123; console.log(i) &#125; &#125;; a[2](); 12345678910111213141516171819 在这个块级作用域中，你又定义了一个函数，而这个函数又引用了函数外部的 i 变量，那么这就产生了闭包，也就是说，所有块级作用域中的 i 都不会被销毁，你在这里执行了 10 次循环，那么也就创建了 10 个块级作用域，这十个块级作用域中的变量 i 都会被保存在内存中。 那么当你再次调用该 a[n]() 时，v8 就会拿出闭包中的变量 i，并将其打印出来，因为每个闭包中的 i 值都不同，所以 a[n]() 时，打印出来的值就是 n，这个就非常符合直觉了。 但是如果你将 for 循环中的 i 变量声明改成 var，那么并不会产生块级作用域，那么函数引用的 i 就是全局作用域中的了，由于全局作用域中只有一个，那么在执行 for 循环的时候，i 的值会一直被改变，最后是 10，所以最终你执行 a[n]() 时，无论 n 是多少，打印出来的都是 10. 那么这就是 bug 之源了。2. 循环打印 1，2，3，4，5 和第二种思路比较相似，同样是在 setTimeout 外面再套一层函数，只不过这个函数是一个**立即执行函数** 。利用立即执行函数的入参来缓存每一个循环中的 i 值： &#96;&#96;&#96;js for (var i &#x3D; 0; i &lt; 5; i++) &#123; &#x2F;&#x2F; 这里的 i 被赋值给了立即执行函数作用域内的变量 j (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125; //就是每一次 settimeout 里的 j 对外部立即执行函数里的变量造成了引用，所以，缓存了这个值，因为 v8 不再回收这个被引用的值了，缓存了下来。 闭包的应用模拟私有变量 模拟私有变量：就是之前像是 Java c++ 这些，有 private 私有变量， 就是不是这个类的其它成员，你无法去访问这些私有变量。 在 js 生成一个类是依赖于这个构造函数，但是你实例化一个类会发现，你通过这个类可以访问到这些这个类的属性，但是这个有一个问题就是说，万一我在这个这个构造函数里定义了一些私密数据，那不就可以在这个对象去访问到这个属性了吗。 用立即执行函数，形成一个闭包，返回一个类，然后将私有属性放在函数里，不去通过 this 来赋值，直接进行赋值操作；a=privatedata，这样外部是无法拿到这个私有变量的。 还可以用”symbol:”&gt; 可以用来定义一个绝对唯一的常量，避免命名冲突。 模拟私有变量，就是通过这个定义的属性是私有的，类似于之前通过立即执行函数，来实现的一个私有变量”闭包是如何来实现这个私有变量的”&gt; #### 模拟私有变量 模拟私有变量：就是之前像是 Java c++ 这些，有 private 私有变量， 就是不是这个类的其它成员，你无法去访问这些私有变量。 在 js 生成一个类是依赖于这个构造函数，但是你实例化一个类会发现，你通过这个类可以访问到这些这个类的属性，但是这个有一个问题就是说，万一我在这个这个构造函数里定义了一些私密数据，那不就可以在这个对象去访问到这个属性了吗。 用立即执行函数，形成一个闭包，返回一个类，然后将私有属性放在函数里，不去通过 this 来赋值，直接进行赋值操作；a=privatedata，这样外部是无法拿到这个私有变量的。 还可以用”symbol:”&gt; .来模拟一个私有的变量。 偏函数 bind 的实现 “bind” 思路详解 个人理解 二刷理解： 第一点： 记住执行 bind 会返回一个函数，为什么为了之后的偏函数的应用，s.（a）（b） 返回的函数需要调用它并且来改变它的 this 指向，利用 apply 此时来考虑一下，类数组的问题，就是说，bind 函数里面有许多参数，被 arguements 所收集，你现在想传参数，但是 arguements 是一个类数组，需要转换为真正的数组，利用 array.propotype.slice.call() 此时 bind 还具有偏函数的特性就是 bind 函数第一个括号内部，偏函数就是在第二个括号里的参数,为什么第一个括号里的参数要截取，因为我不需要第一个括号里面的第一个参数，所以要截取，对于第二个括号，只需要将其转化为数组就好，但是所谓偏函数的本质依然要将其两个参数里的东西转换为一个括号里的参数，所以我们需要合并 concat 可以通过 bind 所返回的函数，实例化一个对象 柯里化 多个参数的函数转转化为单个参数的函数。 防抖节流 “防抖&amp;节流”&gt; 思想 节流就是，n 秒内，只触发一次。（timer 无值了，说明第一次的定时任务执行完毕） 防抖就是 n 秒内，触发多次只看最后一次触发，的中间多次触发，会重新计时。（timer 有值得情况会删除之前的定时器） 执行 fn，this 就指向 window 了，要指向触发的 dom 节点，所以要调用 apply 绑定 this。 一定要把这个 timer 放在外面，因为要形成一个闭包，这样在内存中由于闭包，就不会导致这个变量被销毁，这样能够保证多次触发函数所引用的变量是一个 timer. 12345678910111213141516function throter(callback, delay) &#123;//节流 let timer;//闭包应用 return function () &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; callback.apply(this, arguments) &#125;, delay); &#125; &#125;&#125;input.addEventListerener(&#x27;keyup&#x27;, throter(function () &#123; console.log(input.value);&#125;, 1000)) 123456789101112131415161718192021function debance(callback, delay) &#123;//防抖 let timer = null;//闭包的应用 return function () &#123; if (timer) &#123; clearTimeout(timer)//清空定时器操作 &#125; else &#123; timer = setTimeout(() =&gt; &#123; callback.apply(this, arguments) timer = null &#125;, delay); &#125; &#125;&#125;input.addEventListener(&#x27;keyup&#x27;, debance(function () &#123; console.log(input.value);&#125;, 1000)) 。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"V8引擎执行代码","slug":"V8引擎如何执行一段代码","date":"2020-12-01T13:43:45.000Z","updated":"2021-03-04T15:33:56.148Z","comments":true,"path":"2020/12/01/V8引擎如何执行一段代码/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/","excerpt":"","text":"V8 引擎如何执行一段代码编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 全局执行上下文，创建阶段，首先会创建一个全局对象window，创建一个this 然后让它指向这个window，之后为变量和函数分配空间/并且要为变量赋一个undefined，创建作用域链，全局作用域里面有全局变量，全局函数，想来存储对象，不得需要创建存储的空间吗/堆 —栈，事件循环系系统web-api。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于&amp;混合编译执行/解释执行，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"最长子序列","slug":"最长子序列","date":"2020-12-01T12:20:00.000Z","updated":"2021-03-12T08:32:46.194Z","comments":true,"path":"2020/12/01/最长子序列/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 再次复盘 这道题首先看到了最长，最值问题，动态规划正是在解决，最优子结构，就是说一个问题的最优解，是由许多子问题的最优解组合的，并且这个划分子问题的过程就是降低问题复杂度的过程。 这个题首先分析问题，怎么来分解它降低问题的复杂度，就是倒推思考，求f(i) 前i个元素，并包括，i这个元素的求解，第f(i-1) 这个解，只要知道这个解了那就意味着，知道了f(i)的解，那也就是说要递推求解每一个子序列的最优解，最优子结构； 那就来找状态转移方程：f(n)=maxf(i)+1 //前提是i&lt;n 并且nums[i]的值要小于nums[n]这样才能来延长子序列，否则没有延长的必要三刷反思 首先就是说这个题应该是这样就是说，动态规划是这样就是我看到这个题联想双重循环，为什么就是因为这个题我需要去，在遍历每一项，都要从头再次遍历，因为想回过头来看一个问题就是说，只有当前外层遍历到的元素比之前元素大。 思路： 就是每次遍历到每一个元素的时候，内部再去从头遍历，，只有那些值比外层循环遍历到的值小才可以去更新这个dp方程，由于我所定义的dp是第i项的最长递增子序列，只有那些值小的才可在这个基出上加1，并且为什么是 把自身也带上，就是因为当遍历到某一项的时候，是有多个子序列，我需要找最长的那个，才是正真的第I项的最大值，当遍历完毕后，再去更新最大值，只有内层循环完毕，才有必要去，更新最大值，否则你的第i项有可能不是最大值。var lengthOfLIS = function(nums) &#123; if(!nums.length)&#123;return 0&#125; let maxlenght=1 let dp=new Array(nums.length).fill(1) for(let i=1;i&lt;nums.length;i++)&#123; for(let j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; dp[i]=Math.max(dp[i],dp[j]+1) &#125; if(dp[i]&gt;maxlenght)&#123; maxlenght=dp[i] &#125; &#125; &#125; return maxlenght &#125;;//o(n2) o(n)","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"垃圾回收机制","slug":"垃圾回收机制","date":"2020-11-25T14:14:00.000Z","updated":"2021-03-15T07:29:15.007Z","comments":true,"path":"2020/11/25/垃圾回收机制/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制分类为什么要分类—依据 代际假说 一些变量生存周期很短 存放在新生代区域 一些比如window这些存活时间很长的对象 存放在老生代区域 依据生存周期的长短–因地制宜的选取对应的算法来回收 堆/划分的 目的就是为了能根据不同的对象依据对应的垃圾回收机制，进行回收 新生代 存储生存周期短的对象 区域划分依据scanverge算法 对象区域 空闲区域 老生代 专门存储，生存周期长的对象 主垃圾回收器 专门处理老生代里的对象 算法 标记–整理 标记–清除 步骤 先进行标记–对于清除的对象先进行标记 利用标记–整理算法将活动对象，全部移动到一端 这一步的意义是什么 因为随着你频繁删除堆里所存储的对象，必然会导致内存空间不连续 这个是让内存空间尽可能的连续 再去清除除过这一端的其它垃圾数据 副垃圾回收机制 scanverge算法 专门处理新生代里存储的对象 步骤 利用标记—清除算法清除对象区域里标记的垃圾数据 在标记–清除阶段将活动对象复制到空闲区域，并进行整理 为的就是能够使存储空间尽可能的连续 对象区域和空闲区域调换 首先来明确一下什么样的变量的空间可以被回收依赖可访问性算法通过GCroot对象遍历内部所有对象 window Dom节点 通过GCroot 对象访问变量 可访问到的：活动对象 不可访问：非活动对象 V8引擎清除的将是非活动对象 在早期有一个局限性较大的垃圾回收机制引用计数法 它具体是怎么做的 每产生一个引用就计数加一 什么是引用？ 那它的局限性在哪 它无法识别循环引用的场景，无法使计数为0; eg:A对象的引用指向B，而B的引用又指向A，它们的引用计数都是1，无法成为0, 就会造成内存泄漏； 为0就会被回收","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTP(复盘）","slug":"http(复盘）","date":"2020-11-13T01:20:47.000Z","updated":"2021-03-24T01:27:44.344Z","comments":true,"path":"2020/11/13/http(复盘）/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/13/http(%E5%A4%8D%E7%9B%98%EF%BC%89/","excerpt":"","text":"http(复盘）http/发展历程http1.1 优势/主要是针对其格式方面的 简单 只由报文首部（由简单的文本形式构成）和报文主体来构成，结构简单 灵活易扩展 没有对http请求的方法/响应码做死规定，开发人员可以进行扩展 它的灵活性还体现在，它本身是在应用层的/之下的其它层可以随意变化 https 直接就在http和tcp之间加入了TLS/SSL安全传输层 http3.0 直接将tcp层换为了UDP层 跨平台 移动端pc端/游戏 弊端 无状态 怎么解决这个问题/cookie 技术 明文传输 用https协议解决 性能 长连接 客户端在向服务器发出http请求的时候，之前要来建立tcp连接–你想想，你稳定连接都没有来建立怎么来发送请求//这里有问题 早在1.0版本的时候，每发一个请求，都要来建立一个tcp链接，那么就非常的消耗资源，那么为了解决这个问题，http1.1版本用长链接，只要双方没有主动断开连接的意愿，那么这个连接就不会断开//完全正确 管道网络传输 正是因为长连接给管道网络传输创造了条件 就是说在一次tcp连接中，同时发出多个http串行请求//并不是在多路复用 这里我需要来补充一点就是说，虽然可以同时发出多个请求，但是服务器这里接收还是按照顺序的，也就是说还是会阻塞的 弊端：队头阻塞 怎么会出现这个状况 原因就在于http1.1版本采取的是串行请求，可以理解为顺序请求，只要第一个请求发出，但是因为某种原因而被阻塞了，那么之后的请求也都会被阻塞，也就是说客户端会一直收不到想要的数据 HTTPShttp2.0 特点 报文格式采取二进制 构成 头信息帧 数据帧 这样做的目的就是为了能够方便计算机接收数据 报文的格式是一种数据流 报文传输的过程是一种双向数据传输流 彼此之间是以流的形式去传输的 多路复用 其实就是http多个请求基于同一个tcp连接 移除了1.1的串行请求：也就是说可以并发接收请求（有点像异步，任何一个请求都不会阻塞其它请求） 头部压缩技术 为什么要有头部压缩技术–其实是因为header 里面存有一些固定的头字段：useragent cookie accept 等这些多达几百字节，并且还有好多的重复头部 HPACK压缩算法，废除了http1.1的起始行的概念，它将原来的url，请求头方法，全部转换为伪头字段,以冒号（：）开头eg: :method, :status 给那些重复的字段信息，引入了静态表，双方会共同维护这个静态表 但是如果没有在静态表里找到我想要的信息，之后会紧跟着一个动态表，会不断的更新信息 优势：减少请求的头部开销，提高网络传输的效率，如果有重复的头部信息，直接带上索引号就可以解决了 安全性 基于TLS握手所构成的 那为了能够区别于https，会在tls握手结束后发给服务器一个连接前言，告诉服务器，我是http2协议而不是其它的协议 弊端 其实这里只是解决了部分的对头阻塞（应用层，别忘了还有传输层的）问题：并没有完全的解决—为什么下层tcp就还是会出现队头阻塞问题- 因为一旦tcp报文，有丢失直接触发了tcp的重传机制-服务器只有接收到了丢失的报文，才会去继续接收—也就是说其它报文来了也没用 核心：流与多路复用 本质是双向的数据传输序列 同一个id号 流ID 由于多路复用的问题-多个请求是乱发的 并且发请求的时候头帧/数据帧是打乱的，但是属于同一个请求/回应的流的会分配相同的id 接收方根据流id重组，排序收来的帧，形成流 但是由于http2里帧结构会有流标识符 具体就是当我此时发出一个请求后，这个请求会有一个流id，响应信息也会有一个与之相同的流id,这就意味同属一个流，即便 http3.0版本 从根本上解决了队头阻塞 为什么 由于tcp建立的是可靠连接，所以当http包丢了会触发重传机制–也就会阻塞其它http请求–http2.0并没有完全的解决队头阻塞的问题 所以http下层的传输层采取了UDP udp采取的是不可靠传输–发了不管对方是否接收到–一个流阻塞了，仅阻塞这个流，其它流根本就不管 安全性 基于最新的TLS1.3 但是，会将其警报消息，握手消息，封装为自己的QUIC帧 也就是说并不是完全的依赖于TLS协议 为什么要用不透明的ID意义是什么 请求方法GET 安全幂等 这里我印象中好像是因为是只读操作所以，不会对服务器的资源造成影响，所以是安全的/至于幂等应该是针对服务器来讲的，就是说多次操作不会造成服务器的资源改变//幂等可以这样来理解//所谓幂就是多次操作的意思 POST 不安全也不幂等 状态码它有哪些分类呢 1×× 服务器收到了客户端的请求（但是还没处理） 2×× 收到了请求，并且产生了回应 3×× 资源重定向，意思就是，服务器这里没有客户端想要的资源，响应头部包含了一个location,(告诉客户端你想要的资源都在这个地址去寻找吧） 4×× 客户端错误（意思就是客户端访问了服务器所没有的资源） 5×× 服务器错误（就是服务器自己出现了bug无法返回客户端所需要的资源) 常见状态码 200 成功 301 永久重定向，就是说当第一次服务器给了客户端这个重定向地址之后，客户端再次访问的时候就会直接去访问 302 临时重定向，这个是每次客户端访问还是要访问原地址，之后再到重定向的地址eg:访问百度搜索引擎里的内容，都是先跳转至百度网址，然后再跳转至重定向的地址 304 距离上次请求网页的内容不会改变，所以服务器不会来返回的内容，这个时候客户端应该是直接向本地缓存请求数据了 404 客户端错误，资源未找到 500 服务器本身错误 504 网关超时-服务器内部网络超时 组成所谓超文本 就是图片/视频/连接 核心，在于有链接跳转至另一个超文本 传输 两点之间进行传输 你怎么理解它这个两点之间的传输 它是一种协议 它是一种双向传输协议 就是说客户端与服务器通信，客户端发送请求，服务器响应请求/双向的 Headerrequiredheader Accept 浏览器发出http的请求的目的是什么是不是在请求资源–但是浏览器并不是能够接受所有资源格式// Accept 浏览器能够接受的资源格式 Accept-encoding 那现在浏览器已经能够接受到了资源–但是客户端的资源总是有限的此时服务器需要来压缩资源再发送给浏览器 那我总得告诉一下服务器我能够接受的压缩算法吧 Accept-encoding Cookie 这个逻辑我不理解 Host 你想你想访问资源总得知道地址吧/包含着访问的域名 useragent 包含着浏览器的信息/操作系统的信息 比如我是windows/chrome浏览器 connection: keep-alive 告诉服务器采取长连接模式 responseheader content-type 服务器返回给浏览器的资源格式 content-size 返回的数据字节数 content-Length 返回的数据多少字节 content-encoding 服务器要告知我所采用的浏览器压缩格式目的是方便浏览器根据这个格式解压缩 cache-control no-cache Subtopic 子主题 子主题 Etag connection: keep-alive 服务器采取长连接模式 主题主题","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"二叉树层序遍历","slug":"二叉树层序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-15T08:25:27.678Z","comments":true,"path":"2020/11/12/二叉树层序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"题目链接二叉树层序遍历 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 思路： 总结算法题的思路，不宜过于细节 首先确定是双 while 循环为什么，因为牵扯到二次遍历，就是在遍历到每一层后，在这个每一层的基础上，再次去遍历下一层的数据并且去出队 其次确定需要两个数组，首先需要结果数组，自己看示例是不是内部还需要数组。对吧所以还需要存储每一层的数据的数组。 层序遍历题全部都用一个方法，并且**时间空间复杂度都为 o(n),**每个节点都遍历，且空间复杂度取决队列，一般看到这个模拟队列，栈出现线性增长 。都是 o(n) 12345678910111213141516var levelOrder = function(root) &#123; if(!root)&#123;return []&#125; let queue=[root] let res=[] while(queue.length)&#123; let len=queue.length res.push([]) //每一层循环遍历完毕后都会去再次推入新的一层 while(len--)&#123; let n=queue.shift() res[res.length-1].push(n.val) if(n.left)&#123; queue.push(n.left)&#125; if(n.right) &#123; queue.push(n.right)&#125; &#125; &#125; return res&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"翻转链表","slug":"反转链表","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-15T07:52:16.110Z","comments":true,"path":"2020/11/12/反转链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表思路（联想三个指针不断的交换） 如实记录几个月后的复盘结果，就是说自己第一次复盘的时候想到了双指针但是自己想的是一个指向了头，一个指向了尾元素，然后交换，思路完全错误了，错在了哪里 首先对撞指针，更适用于两个元素交换，但是这个题的要求是让反转，而且双指针有一个问题就是说，当两个指针进行交换的时候，下一个节点不就丢了吗 引出了三指针进行交换。 题解思路 核心点三指针，每次只通过 cur.next=pre 来循环翻转 并且每次都需要缓存 next 指针为什么，就是因为你每次都翻转完毕后 cur 的 next 指向会丢失，所以你遍历的时候首先就需要来缓存它。 其次还有一个小细节就是为什么，循环的条件没有 next 不为空，因为为空无所谓，但是删除链表这个题考虑下一个元素主要是是因为，都为空了，就没有去重的必要了，也就是说不必去循环了。 1234567891011var reverseList = function(head) &#123; let pre=null; let cur=head; while(cur)&#123; let next=cur.next; cur.next=pre; pre=cur; cur=next; &#125; return pre&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"工具页测试","slug":"工具测试","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-04T15:36:19.498Z","comments":true,"path":"2020/11/12/工具测试/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"盒模型","slug":"迭代法先序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2021-03-05T15:36:38.595Z","comments":true,"path":"2020/11/12/迭代法先序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"先来明确一点，为什么一定要用栈，这里我一直遗漏了一点就是 在递归中，再不断调用函数自身的时候，会形成一个调用栈，每调用一次就推入一个函数，执行完毕就去释放？这里不是特别理解理清一下思路（时刻记住其实这个是由递归来改进的） 先设置一个栈结构–为什么为了能够使用栈来模拟调用栈的过程 之后再访问根节点 那怎么来访问根节点，是不是先来入栈，后再来弹出栈，来模拟每调用一次就推入栈，结束后再去弹栈 123456789101112function prorder (root)&#123; const stack=[root]; if(!root) &#123;return&#125;; while(stack.length)&#123; const n=stack.pop();//注意一下这里shift()才是在弹首元素，pop()弹的是尾元素 console.log(n.val); if(n.right) &#123;stack.push(n.right)&#125;; if(n.left) &#123;stack.push(n.left)&#125;; &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"后序遍历","slug":"迭代法后序遍历","date":"2020-11-11T14:20:47.000Z","updated":"2021-03-05T15:36:29.742Z","comments":true,"path":"2020/11/11/迭代法后序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"首先来捋一下思路 后续遍历的顺序是先左子树，再右子树，再根节点 那么从这你思考一下如果我把这个顺序颠倒一下是什么是不是先根节点，再右子树，再左子树，是不是非常的像先序遍历，及就是说把先序遍历的结果再入栈，然后根据栈的先进后出的特性，来得到后序遍历的结果 1234567891011121314151617function lastorder (root) &#123; if(!root)&#123;return&#125; const outstack=[]; const stack =[root]; while(stack.length)&#123; const n=stack.pop(); outstack.push(n) if(n.left) &#123;stack.push(n.left)&#125; if(n.right)&#123;stack.push(n.right)&#125; &#125; while(outstack.length)&#123; const m=outstack.pop() console.log(m.val) &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"GET 和 post 本质区别","slug":"GET和Post本质区别","date":"2020-11-11T01:20:47.000Z","updated":"2021-03-15T03:35:44.602Z","comments":true,"path":"2020/11/11/GET和Post本质区别/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/GET%E5%92%8CPost%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/","excerpt":"","text":"##👱 GET 和 post 本质区别 叙述思路 首先属于 HTTP 协议—–》 引出本质是 TCP 连接——》 引出 tcp 连接次数问题—–&gt; 由次数问题：想到幂等。 其次想到安全幂等，GET 安全幂等，POST 不安全也不幂等。 其次想到想起它们属于 HTTP 协议，也就是说也是基于 TCP 链接的，所以它们的本质都是 TCP 连接。 GET 请求是一个 tcp 报文 :(对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）。) //你请求肯定要有请求头吗，对吧 而 POST 请求是两个 tcp 报文，(浏览器先发送 header，服务器响应 100，浏览器再发送 data，服务器响应 200 ok（返回数据）。) 所谓安全就是不会改变服务器资源，所谓的**幂**想起次幂，也就是说多次的意思 所谓的不安全其实就是会改变，服务器的资源，所谓的不幂等就是，多次操作结果不相同。 💯 100 continue HTTP 100 Continue 信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.// 自己的话就是:👌 因为是 100 分所以目前状态正常，可以继续请求。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2021-03-04T15:32:19.837Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"执行上下文于调用栈","slug":"执行上下文","date":"2020-11-02T04:20:43.000Z","updated":"2021-03-04T15:33:07.791Z","comments":true,"path":"2020/11/02/执行上下文/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"执行上下文所谓的执行上下文其实就是代码所处的环境分类全局执行上下文函数执行上下文eval执行上下文–我不用调用栈每当执行上下文创建一个就将起推入调用栈中，然后当函数执行完后，对应的函数执行上下文才会出栈，从而让出资源空间 从这里开始，就可以知道作用域的本质了，其实就是当前所处的执行上下文了 那为什么作用域外部无法访问到另一个作用域的内部 原理其实是因为当外部执行上下文想要去访问函数执行上下文里的变量的时候，它出栈了自然是无法访问了 那为什么内部作用域又能去访问外部作用域 其实这是因为zhi’x 全局执行上下文执行过程 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 执行阶段 js引擎开始一行行执行代码，并开始给变量赋值 由此引出了变量提升的本质 其实是因为js的执行上下文的创建阶段和赋值阶段并不同步所造成的 创建阶段给变量开辟空间然后赋了初值undefined 之后赋值的时候由于在访问的变量的时候，要去赋值的代码还未执行，所以依然是undefined 函数执行上下文（调用时才会推入调用栈中） 创建阶段 首先明确一点这个是在函数调用的时候才生成的 创建this 将其指向调用者 无人调用就指向window 也就是说，普通函数之所以this指向window其实是这里指定的 创建arguements 这里面包含着函数所有的参数 创建作用域链 是这样你想一想，你在全局执行上下文已经有了全局对象了，那函数执行上下文自然不用再去建立了 执行阶段 一行行执行函数内部的代码 那为什么一定要有他，存在的意义是什么，其实从网络体系分层的思想可以看出来，目的就是在解耦，降低代码执行的复杂度","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"HTTP3展望","slug":"HTTP3展望","date":"2020-10-11T01:20:47.000Z","updated":"2021-03-24T01:27:10.781Z","comments":true,"path":"2020/10/11/HTTP3展望/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/11/HTTP3%E5%B1%95%E6%9C%9B/","excerpt":"","text":"HTTP3展望http2的阻塞具体是怎么来发生的首先 会建立tcp连接，连接完毕后，http报文会基于tcp发送流，但是这个流会被tcp拆分为更小的segment,然后再去发送可能丢包导致tcp重传机制HTTP3连接顺序 客户端需要先来和服务器之间用HTTP2来连接 服务器发送Alt-Svc帧 告诉客户端这里提供的是http3协议而不是http2 客户端 改用http3来收发数据 基于UDP不再去依赖于tcp头部压缩算法QPACK算法 主要对于http2的hpack做出了升级 就是之前的静态表的更新是双向的，如果更新多个发出多个请求 QUIC把除过tcp建立连接，断开连接机制舍弃，学习tcp的流量控制，拥塞窗口 取其精华，取其糟粕 特点 基于udp不需要握手，速度快 引入类http2的流与多路复用 quic协议基于udp实现了可靠传输，（udp早已改进，不再是以前不靠谱的协议了）//类似于tcp 基于ip实现了可靠传输 安全性 基于tls1.3 但是是基于quic将tls一些信息包装成自己的帧，省掉一次开销是什么意思","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Websocket","slug":"websocket","date":"2020-10-05T13:43:45.000Z","updated":"2021-03-24T01:26:41.163Z","comments":true,"path":"2020/10/05/websocket/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/05/websocket/","excerpt":"","text":"websocket它解决了http是半双工，实现了服务端推送也就是说客户端和服务器之间无法，随意互相发送数据，只能是客户端，发，服务器去接受，服务器无法主动发送数据，只能是被动的那为了能够实现类似全双工的效果，http做出了哪些努力，轮询 其实就是说，客户端会向服务器不断的发送询问，问是否有新的数据，那么很明显这样做，效率非常的低 长轮询 意思就是说只有对方有数据才会发，每次客户端仅在接受到新数据才会去询问，如果，没有那就不询问了 那么websocket是怎么来建立连接的（握手）其实首先初始本质就是一个http的get 请求（之所以这样做其实是为了能够，绕过浏览器，防火墙的限制，因为这样做，但是这里为了能够告诉服务器其实并不是http协议，会加入两个字段：并且还会加入一些验证消息，目的就是为了能够防止误连接建立了连接，并且确认了就是websocket协议，之后客户端和服务器之间就可以随意互发信息了这个协议更多的是对http的一种优化二进制帧格式","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2021-03-22T13:28:07.666Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2021-03-15T07:43:41.719Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"盒模型 首先盒模型有几个属性分别是 content border padding margin ; 盒模型有两种标准，第一种是 w3c（万维网联盟） 首先盒模型有几个属性分别是 content border padding margin ;就是实际元素宽高是考虑，边距和边界的。 你所设定的 height width **是不包括这个 **border 和边距（padding) 第二种：是传统的 IE 浏览器模型：box-sizing:border-box; 也有几个属性分别是 content border padding margin ; 实际元素的宽高是不考虑，这个边距和边界的。 但是其元素 width height 的计算是包含了 border. 什么意思，就是说我可以并排的展示两个加上 border 超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"垂直水平居中：margin:auto 原理","slug":"垂直水平居中： margin原理","date":"2020-09-11T01:20:47.000Z","updated":"2021-03-15T07:32:50.524Z","comments":true,"path":"2020/09/11/垂直水平居中： margin原理/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/11/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%EF%BC%9A%20margin%E5%8E%9F%E7%90%86/","excerpt":"","text":"margin: auto 原理 第一种可以用 flex 布局 给父元素，去设置 123 display:flex;justify-content:center//水平居中； align-item:center//垂直居中； ``` css#center { background-color: red; width: 200px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;}1234567891011121314151617181920212223242526274. auto 就是“一样”的意思，如果是左右 auto 的话，意思就是： 这个 DIV 离 左边的距离 跟 右边的距离 是一样的。 margin:0px auto；就是上下的距离是 0px，左右的距离是“一样”。5. **叙述思路**： 垂直方向上，auto 不会自动填充，水平方向上不会去自动填充，所以此时通过，绝对定位并设置上下左右边界，触发流体特性，这样垂直方向上就可以进行自动填充了，从而达到垂直方向上居中的操作。6. 1. 解释下原理: 1 在普通内容流中，margin:auto 的效果等同于 margin-top:0;margin-bottom:0. 2 position:absolute 使绝对定位块跳出了内容流 3 为块区域设置 top: 0; left: 0; bottom: 0; right: ;将给浏览器重新分配一个边界框 ，使元素具有流体特性，此时该元素的所有可用空间，所以 margin 垂直方向上有了可分配的空间。 4 再设置 margin 垂直方向上下为 auto ,即可实现垂直居中。(注意高度得设置) 5. 动画属性：transform:就是 &#96;&#96;&#96; css #center &#123; position:absolute; left:50%; right:50%; transform: translate(-50%,-50%) &#x2F;&#x2F;其实就是因为刚开始，元素左顶点位于中心，所以此时让这个元素相对于自身往左移动50%，再往上移动50%，由于css动画是上负下正，和数学坐标是相反的。 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"最小路径","slug":"最小路径和","date":"2020-02-03T14:22:00.000Z","updated":"2021-03-15T08:26:48.012Z","comments":true,"path":"2020/02/03/最小路径和/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/03/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"解题链接64. 最小路径和 第一次求解并不完美：需要二次复盘。 第二次复盘：非常失败：好好反思： 解题描述 给定一个包含非负整数的 m* n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明： 每次只能向下或者向右移动一步。 思路 考虑特殊情况，就是如果路径包含了第一行/第一列，你得提前来考虑。 特点：无法通过状态转移方程来求得，就需要提前将其求解。 这个题最大的难点除了要去提前初始化数组，更重要的是要掌握定义二维数的方法。 dp 方程在内部块中，每一个元素的解都是由上方向以及左方向的最小路径和的元素求解： dp[i][j] =Math.min(dp[i-1][j],dp[i][j-1])所求得。 let dp = Array.from(&#123; length: m &#125;, () =&gt; new Array(n).fill(Number.MAX_VALUE)); let dp = Array.from(new Array(n), () =&gt; new Array(m)); 1234567891011121314151617181920212223242526#### 初代代码参考：&#96;&#96;&#96;jsvar minPathSum &#x3D; function(grid) &#123; if (grid.length &#x3D;&#x3D;&#x3D; 0) &#123; return 0; &#125; let m &#x3D; grid.length; let n &#x3D; grid[0].length; let dp &#x3D; Array.from(&#123; length: m &#125;, () &#x3D;&gt; new Array(n).fill(Number.MAX_VALUE)); &#x2F;&#x2F;用来定义二维数组的。 dp[0][0]&#x3D;grid[0][0] for(let i&#x3D;1;i&lt;m;i++)&#123; dp[i][0]&#x3D;dp[i-1][0]+grid[i][0] &#125; for(let j&#x3D;1;j&lt;n;j++)&#123; dp[0][j]&#x3D;dp[0][j-1]+grid[0][j] &#125; for(let i&#x3D;1;i&lt;m;i++)&#123; for(let j&#x3D;1;j&lt;n;j++)&#123; let itemMin &#x3D; Math.min(dp[i - 1][j], dp[i][j - 1]) dp[i][j] &#x3D; Math.min(itemMin + grid[i][j], dp[i][j]) &#125; &#125; return dp[m-1][n-1]&#125;; 解题参考https://leetcode-cn.com/problems/minimum-path-sum/solution/javascriptcong-lei-si-de-ti-mu-chu-fa-dong-tai-gui/ 个人反思 最近觉得算法题学习效率很差，但是不知道该怎么做，不知道该怎么做，目前是这样子，我发现，这样不行，单次超过一定的时间，才弄懂的大概率遇到原题了，估计也会出问题，还是需要多次重复，并且一定要搞清楚每一步的意义所在，而不是凭借印象去做，不要死磕。 反思问题所在：就是自己没有搞清楚二维数组的坐标表示 –以后凡是见到了二维数组的表示，一定记得就用（i,j)表示，但是你要注意一下，就是说这个 i 是列的数字，j 是横向的数，一见到二维数组，脑子里就去想一个二维表，每一个点就是（i,j) 。 其次没有搞清楚双重循环的的先后顺序，这样想，联想”二叉树层序遍历”，就是说在遍历完一层后，再去遍历下一层，也就是说，双重循环的本质就是外层遍历一遍，里层全部遍历完毕，那也就是说先固定 i 不断的循环遍历 j 的值，因为你默认坐标的表示就是(i,j)。 三刷反思1 . dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) +grid[i][j] for 循环求解特殊情况： 第一个横行元素，和第一个纵列元素错误在于自己还是**没有搞清楚二维坐标的问题**没有搞清楚，初始判空的条件，其实这里判空主要是想规避 grid 本身就是一个空数组的问题，因为如果 grid 直接就为空的话，那不就，是为 Null 吗，把 Null 赋给一个变量有何意义双循环里 如果为 0 那不就出现了负数吗对吧","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS数组本质","slug":"js数组本质","date":"2020-02-03T13:20:47.000Z","updated":"2021-03-15T07:49:34.576Z","comments":true,"path":"2020/02/03/js数组本质/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/03/js%E6%95%B0%E7%BB%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"js 栈和堆个人理解就是简单数据类型，都放在栈中，复杂数据类型对象的地址存放在栈中，在堆中存储这个对象的值。 如果是 let a=1 a=’scx’ 对于简单数据类型的仅重新赋值，不会去开辟空间。 谁块：栈块，因为栈先进后出的数据结构更加的简单，栈是编译时系统自动分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。并且每次访问用类型数据都是先访问栈里的对象的引用，然后再去找堆里的对象。所以步骤多了，慢。 js 数组为什么不需要去分配固定的空间 v8 如何来实现这个 js 的数组。 js 里的数组是一个特殊的对象，为什么数组长度可变，为什么这个数组可以存储多个类型数据，因为是一个对象。快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，慢数组是用类似哈希表的形式创建的。 如果 v8 引擎发现数组内部出现了大量空洞，就是比如 arr=[1,3] arr[1222]=1 ,那就转为慢数组，因为不需要去申请大量连续空间，但是是以一种 hash 表来展示的。 慢转快；就是这个，js 数组的空洞少的时候就会去转换，这就是为什么 js 不需要分配固定长度的本质原因。","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS继承","slug":"继承","date":"2020-02-01T14:20:47.000Z","updated":"2021-03-15T07:51:16.832Z","comments":true,"path":"2020/02/01/继承/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/02/01/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承 首先来理解这个原型链继承就是将子类的原型对象直接变为，父类的实例，这样就可以通过原型链实现继承，从而拿到一些属性和方法 但是无法传递参数，而且会修改原型上的属性和方法，这里要注意一点就是要改变这个子类构造函数的指向，否则就顺着原型链指向了父类构造函数了，这个组合继承，寄生组合继承都要。 组合继承就是通过这个 call/apply 实现继承，首先子类实例一个对象，然后调用这个子类构造函数，之后再去调用这个父构造函数，改变这个父构造函数的 this 指向，这样并可以传递参数，这样，就给子类赋予了父类的属性和方法，并且由于构造函数声明的属性和方法都是私有的所以其它实例无法改变。并且还可以依赖原型链，去拿到这个父类原型上的方法，弊端就是父类构造函数调用了两次，一次是原型链上的，一次是这个 call 调用父构造函数的时候。 寄生组合继承：就是由于父构造函数调用了两次所以我需要，通过 object.create(父构造函数的 propotype),就是先来创建一个对象，然后让这个对象的_proto_指向这个参数。这样就跳过了这个父的实例，完美，不过也需要修改构造函数的指向。 123456789101112131415161718function parent(name, sex) &#123;//组合继承 this.name = name this.sex = sex parent.prototype.say = function () &#123; console.log(111); &#125;&#125;function child(name, age) &#123; parent.call(this, name)&#125;child.prototype = new parent()//第一次调用这个父构造函数child.prototype.constructor = child//修改这个原型constructor指向let a = new child()//第二次调用这个父构造函数 12345678910111213141516function parent(name, sex) &#123;//寄生组合继承 this.name = name this.sex = sex parent.prototype.say = function () &#123; console.log(111); &#125;&#125;function child(name, age) &#123; parent.call(this, name)&#125;child.prototype = Object.create(parent.prototype)//修改子类原型对象的__proto__为父构造函数的原型对象实现继承父的原型方法child.prototype.constructor = child//修改这个原型constructor指向","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JSONP结合Promise","slug":"jsonp","date":"2020-01-25T14:22:00.000Z","updated":"2021-03-15T07:49:20.794Z","comments":true,"path":"2020/01/25/jsonp/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/01/25/jsonp/","excerpt":"","text":"手写 JSONP 的实现思路 就是由于这个是一个异步的请求，所以需要用这个 promise,来做； …解构的应用： 与对象去使用就是在将里面所有可遍历的属性，进行拷贝。 for in 用来循环对象的属性的 let key for in object; key 就是对象里面的键； join 的用法就是说这个，将里面的值以什么来分割。 这个方法的弊端. 123456789101112131415161718192021222324252627282930function JSONP(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;) window[callback] = function (data) &#123; resolve(data) document.body.removeChild(script)//就是类似于我在做哪个全局loading组件的时候用到的添加节点就是往这个body里添加。 &#125; let arr = [] params = &#123; ...params, callback &#125; // a=1&amp;callback=s for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` document.appendChild(script) &#125;)&#125;JSONP(&#123; url: &#x27;https://loacl:2000&#x27;, params: &#123; a: 1 &#125;, callback: &#x27;s&#x27;&#125;).then(data =&gt; &#123; console.log(data);&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://gitee.com/HEXOS/hexos/categories/%E5%89%8D%E7%AB%AF/"}]}]}