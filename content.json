{"meta":{"title":"Hexo","subtitle":"","description":"","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[],"posts":[{"title":"TCP","slug":"TCP总结","date":"2020-12-22T13:48:45.000Z","updated":"2021-01-26T03:05:23.745Z","comments":true,"path":"2020/12/22/TCP总结/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/22/TCP%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"相交链表","slug":"相交链表","date":"2020-12-01T14:22:00.000Z","updated":"2021-02-09T02:06:01.010Z","comments":true,"path":"2020/12/01/相交链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"160. 相交链表。反思 首先这个题的思路就是来联想一下这个相交节点，为什么要用双指针，就是说 a+b+c=b+1+c 也就是说我，都同时开始且路程相同，那么一定会在相交节点，相遇； 因此思路就是只要我能够判断当前的节点是否为空，如果为空了，那就将其接到下一个链表的头节点，如果不为空的话，那就去继续遍历。 自己的不足在于三元表达式不够熟练，就是自己，变量= 条件 ？ a: b ;也就是说只要条件满足执行 a 结果，不满足就执行 b 结果。 12345678910var getIntersectionNode = function(headA, headB) &#123; if(!headA||!headB)&#123;return null&#125; let p1=headA let p2=headB while(p1!==p2)&#123; p1= p1===null? headB:p1.next p2= p2 ===null?headA:p2.next &#125; return p2&#125;; mermaid 注意： 首先这个题只要求节点相同，没有说这个节点的值问题； 其次判断的条件就是这个有一个为空，必然没有相交的节点所以直接，就返回为空就好","categories":[],"tags":[],"keywords":[]},{"title":"V8引擎执行代码","slug":"V8引擎如何执行一段代码","date":"2020-12-01T13:43:45.000Z","updated":"2021-01-12T14:30:52.915Z","comments":true,"path":"2020/12/01/V8引擎如何执行一段代码/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/","excerpt":"","text":"V8 引擎如何执行一段代码编译阶段 那在执行一段代码执行之前，得做些准备工作，（你做事情不也得需要做准备工作吗），具体就是需要准备基础环境。 全局执行上下文，创建阶段，首先会创建一个全局对象window，创建一个this 然后让它指向这个window，之后为变量和函数分配空间/并且要为变量赋一个undefined，创建作用域链，全局作用域里面有全局变量，全局函数，想来存储对象，不得需要创建存储的空间吗/堆 —栈，事件循环系系统web-api。 那现在有了基础环境后，就可以来执行这个代码。 由于 v8 引擎并不识别代码，所以需要来，将其结构化， 转化为 AST 树，再最终转换为字节码，也就是说中间代码（介于 AST 和机器码中间的一种产物） ，但是 v8 引擎为了节省资源，它不会去将声明的函数内部的所有代码转换为中间代码。很懒惰，所以又称惰性解析，阶段。 执行阶段 同时要说明一点由于 V8 引擎属于&amp;混合编译执行/解释执行，所以会有一个监控器，来判断是否有重复代码执行，如果有将其标记为热点代码，将其转换为二进制代码，当下次再次执行，解释器直接执行优化过的代码，提高效率","categories":[],"tags":[],"keywords":[]},{"title":"最长子序列","slug":"最长子序列","date":"2020-12-01T12:20:00.000Z","updated":"2020-12-25T08:46:57.149Z","comments":true,"path":"2020/12/01/最长子序列/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/12/01/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 再次复盘 这道题首先看到了最长，最值问题，动态规划正是在解决，最优子结构，就是说一个问题的最优解，是由许多子问题的最优解组合的，并且这个划分子问题的过程就是降低问题复杂度的过程。 这个题首先分析问题，怎么来分解它降低问题的复杂度，就是倒推思考，求f(i) 前i个元素，并包括，i这个元素的求解，第f(i-1) 这个解，只要知道这个解了那就意味着，知道了f(i)的解，那也就是说要递推求解每一个子序列的最优解，最优子结构； 那就来找状态转移方程：f(n)=maxf(i)+1 //前提是i&lt;n 并且nums[i]的值要小于nums[n]这样才能来延长子序列，否则没有延长的必要二刷反思 这个题就是说，首先自己在做的时候没有考虑好最大长度何时更新，就是说，只有你此时更新的序列只有比之气的最大长度大才有必要更新，否则，不就变小了吗","categories":[],"tags":[],"keywords":[]},{"title":"翻转链表","slug":"反转链表","date":"2020-11-12T14:20:00.000Z","updated":"2021-02-09T02:05:39.939Z","comments":true,"path":"2020/11/12/反转链表/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表思路（联想三个指针不断的交换） 如实记录几个月后的复盘结果，就是说自己第一次复盘的时候想到了双指针但是自己想的是一个指向了头，一个指向了尾元素，然后交换，思路完全错误了，错在了哪里 首先对撞指针，更适用于两个元素交换，但是这个题的要求是让反转，而且双指针有一个问题就是说，当两个指针进行交换的时候，下一个节点不就丢了吗 引出了三指针进行交换。 题解思路 核心点三指针，每次只通过 cur.next=pre 来循环翻转 并且每次都需要缓存 next 指针为什么，就是因为你每次都翻转完毕后 cur 的 next 指向会丢失，所以你遍历的时候首先就需要来缓存它。 其次还有一个小细节就是为什么，循环的条件没有 next 不为空，因为为空无所谓，但是删除链表这个题考虑下一个元素主要是是因为，都为空了，就没有去重的必要了，也就是说不必去循环了。","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"迭代法先序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2020-11-12T14:37:56.168Z","comments":true,"path":"2020/11/12/迭代法先序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"先来明确一点，为什么一定要用栈，这里我一直遗漏了一点就是 在递归中，再不断调用函数自身的时候，会形成一个调用栈，每调用一次就推入一个函数，执行完毕就去释放？这里不是特别理解理清一下思路（时刻记住其实这个是由递归来改进的） 先设置一个栈结构–为什么为了能够使用栈来模拟调用栈的过程 之后再访问根节点 那怎么来访问根节点，是不是先来入栈，后再来弹出栈，来模拟每调用一次就推入栈，结束后再去弹栈 123456789101112function prorder (root)&#123; const stack&#x3D;[root]; if(!root) &#123;return&#125;; while(stack.length)&#123; const n&#x3D;stack.pop();&#x2F;&#x2F;注意一下这里shift()才是在弹首元素，pop()弹的是尾元素 console.log(n.val); if(n.right) &#123;stack.push(n.right)&#125;; if(n.left) &#123;stack.push(n.left)&#125;; &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"后序遍历","slug":"迭代法后序遍历","date":"2020-11-11T14:20:47.000Z","updated":"2020-11-12T14:37:56.147Z","comments":true,"path":"2020/11/11/迭代法后序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"首先来捋一下思路 后续遍历的顺序是先左子树，再右子树，再根节点 那么从这你思考一下如果我把这个顺序颠倒一下是什么是不是先根节点，再右子树，再左子树，是不是非常的像先序遍历，及就是说把先序遍历的结果再入栈，然后根据栈的先进后出的特性，来得到后序遍历的结果 1234567891011121314151617function lastorder (root) &#123; if(!root)&#123;return&#125; const outstack&#x3D;[]; const stack &#x3D;[root]; while(stack.length)&#123; const n&#x3D;stack.pop(); outstack.push(n) if(n.left) &#123;stack.push(n.left)&#125; if(n.right)&#123;stack.push(n.right)&#125; &#125; while(outstack.length)&#123; const m&#x3D;outstack.pop() console.log(m.val) &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2020-11-05T14:17:18.419Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[],"tags":[],"keywords":[]},{"title":"执行上下文于调用栈","slug":"执行上下文","date":"2020-11-02T04:20:43.000Z","updated":"2020-12-16T08:57:43.124Z","comments":true,"path":"2020/11/02/执行上下文/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"执行上下文所谓的执行上下文其实就是代码所处的环境分类全局执行上下文函数执行上下文eval执行上下文–我不用调用栈每当执行上下文创建一个就将起推入调用栈中，然后当函数执行完后，对应的函数执行上下文才会出栈，从而让出资源空间 从这里开始，就可以知道作用域的本质了，其实就是当前所处的执行上下文了 那为什么作用域外部无法访问到另一个作用域的内部 原理其实是因为当外部执行上下文想要去访问函数执行上下文里的变量的时候，它出栈了自然是无法访问了 那为什么内部作用域又能去访问外部作用域 其实这是因为zhi’x 全局执行上下文执行过程 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 执行阶段 js引擎开始一行行执行代码，并开始给变量赋值 由此引出了变量提升的本质 其实是因为js的执行上下文的创建阶段和赋值阶段并不同步所造成的 创建阶段给变量开辟空间然后赋了初值undefined 之后赋值的时候由于在访问的变量的时候，要去赋值的代码还未执行，所以依然是undefined 函数执行上下文（调用时才会推入调用栈中） 创建阶段 首先明确一点这个是在函数调用的时候才生成的 创建this 将其指向调用者 无人调用就指向window 也就是说，普通函数之所以this指向window其实是这里指定的 创建arguements 这里面包含着函数所有的参数 创建作用域链 是这样你想一想，你在全局执行上下文已经有了全局对象了，那函数执行上下文自然不用再去建立了 执行阶段 一行行执行函数内部的代码 那为什么一定要有他，存在的意义是什么，其实从网络体系分层的思想可以看出来，目的就是在解耦，降低代码执行的复杂度","categories":[],"tags":[],"keywords":[]},{"title":"异步","slug":"异步","date":"2020-10-10T13:20:47.000Z","updated":"2020-11-02T15:28:25.461Z","comments":true,"path":"2020/10/10/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/10/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步先明确一下什么是回调函数就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数那它和异步有什么关系 回调函数能够获得异步任务的结果 那么为什么要有异步有些异步任务实在是太耗费时间了，如果不引入同步机制的化会浪费不必要的时间它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 哪些属于异步任务 settimeout() dom事件 AJAX/AXIOS请求 setinterval() 异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱？？ 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending 初始化的状态 resolved 就是成功执行的状态 resolved会触发then方法 而Then方法所返回的状态为resolved reject 异步任务出错/或是抛出异常的时候 会去触发catch方法 catch所返回的状态还是为resolved 谨记一点就是 promise的状态的改变是不可逆的 一旦成为resolved状态 或是rejected状态 后续改变promise状态的resolve()/reject( )全部失效 有哪些方法 resolve() 这里牢记promise.resolve()所返回的是一个成功状态的promise对象 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务","categories":[],"tags":[],"keywords":[]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2020-11-02T15:28:25.508Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"BFC","slug":"BFC","date":"2020-10-01T13:48:45.000Z","updated":"2020-11-02T15:28:25.524Z","comments":true,"path":"2020/10/01/BFC/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/01/BFC/","excerpt":"","text":"为什么设置over-flow:hidden,可以清除浮动 要了解bfc块，内部的块级元素会垂直摆放，同属于一个bfc块会发生margin重叠，那么消除这样的bug就可以给其中一个元素在套一个容器让他成为令一个新的bfc块（还要设置一个over-flow:hidden). 给父元素加了一个over-flow:hidden就是为了使用bfc块的特性：在计算bfc块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用BFC消除margin重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2020-11-02T15:28:25.492Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[],"tags":[],"keywords":[]}]}