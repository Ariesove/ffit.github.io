{"meta":{"title":"Hexo","subtitle":"","description":"","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[],"posts":[{"title":"盒模型","slug":"迭代法先序遍历","date":"2020-11-12T14:20:00.000Z","updated":"2020-11-12T14:37:56.168Z","comments":true,"path":"2020/11/12/迭代法先序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/12/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"先来明确一点，为什么一定要用栈，这里我一直遗漏了一点就是 在递归中，再不断调用函数自身的时候，会形成一个调用栈，每调用一次就推入一个函数，执行完毕就去释放？这里不是特别理解理清一下思路（时刻记住其实这个是由递归来改进的） 先设置一个栈结构–为什么为了能够使用栈来模拟调用栈的过程 之后再访问根节点 那怎么来访问根节点，是不是先来入栈，后再来弹出栈，来模拟每调用一次就推入栈，结束后再去弹栈 123456789101112function prorder (root)&#123; const stack&#x3D;[root]; if(!root) &#123;return&#125;; while(stack.length)&#123; const n&#x3D;stack.pop();&#x2F;&#x2F;注意一下这里shift()才是在弹首元素，pop()弹的是尾元素 console.log(n.val); if(n.right) &#123;stack.push(n.right)&#125;; if(n.left) &#123;stack.push(n.left)&#125;; &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"后序遍历","slug":"迭代法后序遍历","date":"2020-11-11T14:20:47.000Z","updated":"2020-11-12T14:37:56.147Z","comments":true,"path":"2020/11/11/迭代法后序遍历/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/11/%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"首先来捋一下思路 后续遍历的顺序是先左子树，再右子树，再根节点 那么从这你思考一下如果我把这个顺序颠倒一下是什么是不是先根节点，再右子树，再左子树，是不是非常的像先序遍历，及就是说把先序遍历的结果再入栈，然后根据栈的先进后出的特性，来得到后序遍历的结果 1234567891011121314151617function lastorder (root) &#123; if(!root)&#123;return&#125; const outstack&#x3D;[]; const stack &#x3D;[root]; while(stack.length)&#123; const n&#x3D;stack.pop(); outstack.push(n) if(n.left) &#123;stack.push(n.left)&#125; if(n.right)&#123;stack.push(n.right)&#125; &#125; while(outstack.length)&#123; const m&#x3D;outstack.pop() console.log(m.val) &#125; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"动态规划","slug":"动态规划","date":"2020-11-03T13:20:47.000Z","updated":"2020-11-05T14:17:18.419Z","comments":true,"path":"2020/11/03/动态规划/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划 先明确哪类题用动态规划 特征： 要求达成某个目的的具体个数 不要求具体解法的过程重解法的====结果==== 思维模型是什么 倒着分析问题–咋个倒就是站在问题的==终点==上思考 在终点的基础上，思考能不能==后退==补充：爬楼梯这类题为什么会想到递归的思想，首先它分析后是一个树形结构其次有着重复逻辑，同时谨记着递归要有递归边界–也就是说递归终点防止堆栈溢出 注意一下动态规划的思维顺序–自底向上的思考问题就是由已知出发不断的向上求解未知 动态规划题目的特点 ==量优子结构==–其实人话就是问题的最优解包含着子问题的最优解（这个我不理解）状态转移方程是什么？？？ 所谓==重叠子问题==其实就是递归的过程中–出现了==重复计算==的问题 典型例题 类型： 最值问题 力扣198打家劫舍 问题典型，再多看多回顾","categories":[],"tags":[],"keywords":[]},{"title":"执行上下文于调用栈","slug":"执行上下文","date":"2020-11-02T04:20:43.000Z","updated":"2020-12-16T08:57:43.124Z","comments":true,"path":"2020/11/02/执行上下文/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/11/02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"执行上下文所谓的执行上下文其实就是代码所处的环境分类全局执行上下文函数执行上下文eval执行上下文–我不用调用栈每当执行上下文创建一个就将起推入调用栈中，然后当函数执行完后，对应的函数执行上下文才会出栈，从而让出资源空间 从这里开始，就可以知道作用域的本质了，其实就是当前所处的执行上下文了 那为什么作用域外部无法访问到另一个作用域的内部 原理其实是因为当外部执行上下文想要去访问函数执行上下文里的变量的时候，它出栈了自然是无法访问了 那为什么内部作用域又能去访问外部作用域 其实这是因为zhi’x 全局执行上下文执行过程 创建阶段 首先会创建一个全局对象window： global object 创建一个this 然后让它指向这个window 之后为变量和函数分配空间/并且要为变量赋一个undefined 创建作用域链 执行阶段 js引擎开始一行行执行代码，并开始给变量赋值 由此引出了变量提升的本质 其实是因为js的执行上下文的创建阶段和赋值阶段并不同步所造成的 创建阶段给变量开辟空间然后赋了初值undefined 之后赋值的时候由于在访问的变量的时候，要去赋值的代码还未执行，所以依然是undefined 函数执行上下文（调用时才会推入调用栈中） 创建阶段 首先明确一点这个是在函数调用的时候才生成的 创建this 将其指向调用者 无人调用就指向window 也就是说，普通函数之所以this指向window其实是这里指定的 创建arguements 这里面包含着函数所有的参数 创建作用域链 是这样你想一想，你在全局执行上下文已经有了全局对象了，那函数执行上下文自然不用再去建立了 执行阶段 一行行执行函数内部的代码 那为什么一定要有他，存在的意义是什么，其实从网络体系分层的思想可以看出来，目的就是在解耦，降低代码执行的复杂度","categories":[],"tags":[],"keywords":[]},{"title":"异步","slug":"异步","date":"2020-10-10T13:20:47.000Z","updated":"2020-11-02T15:28:25.461Z","comments":true,"path":"2020/10/10/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/10/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步先明确一下什么是回调函数就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数那它和异步有什么关系 回调函数能够获得异步任务的结果 那么为什么要有异步有些异步任务实在是太耗费时间了，如果不引入同步机制的化会浪费不必要的时间它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 哪些属于异步任务 settimeout() dom事件 AJAX/AXIOS请求 setinterval() 异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱？？ 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending 初始化的状态 resolved 就是成功执行的状态 resolved会触发then方法 而Then方法所返回的状态为resolved reject 异步任务出错/或是抛出异常的时候 会去触发catch方法 catch所返回的状态还是为resolved 谨记一点就是 promise的状态的改变是不可逆的 一旦成为resolved状态 或是rejected状态 后续改变promise状态的resolve()/reject( )全部失效 有哪些方法 resolve() 这里牢记promise.resolve()所返回的是一个成功状态的promise对象 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务","categories":[],"tags":[],"keywords":[]},{"title":"DFS","slug":"DFS","date":"2020-10-03T13:20:47.000Z","updated":"2020-11-02T15:28:25.508Z","comments":true,"path":"2020/10/03/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/03/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"BFC","slug":"BFC","date":"2020-10-01T13:48:45.000Z","updated":"2020-11-02T15:28:25.524Z","comments":true,"path":"2020/10/01/BFC/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/01/BFC/","excerpt":"","text":"为什么设置over-flow:hidden,可以清除浮动 要了解bfc块，内部的块级元素会垂直摆放，同属于一个bfc块会发生margin重叠，那么消除这样的bug就可以给其中一个元素在套一个容器让他成为令一个新的bfc块（还要设置一个over-flow:hidden). 给父元素加了一个over-flow:hidden就是为了使用bfc块的特性：在计算bfc块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用BFC消除margin重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"盒模型","date":"2020-09-12T14:20:47.000Z","updated":"2020-11-02T15:28:25.492Z","comments":true,"path":"2020/09/12/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/09/12/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[],"tags":[],"keywords":[]}]}