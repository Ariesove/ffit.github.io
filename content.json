{"meta":{"title":"Hexo","subtitle":"","description":"","author":"宋辰星","url":"https://gitee.com/HEXOS/hexos"},"pages":[],"posts":[{"title":"异步","slug":"异步","date":"2020-10-31T13:20:47.000Z","updated":"2020-10-31T09:27:25.983Z","comments":true,"path":"2020/10/31/异步/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/31/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"异步先明确一下什么是回调函数就是当一个a函数作为函数b的参数，并且由这个b函数来执行这个a函数//那么a就是回调函数那它和异步有什么关系 回调函数能够获得异步任务的结果 那么为什么要有异步有些异步任务实在是太耗费时间了，如果不引入同步机制的化会浪费不必要的时间它的特点是什么就是异步任务的执行是不会阻塞，之后代码的执行，可以等之后的任务执行后再去执行；一言以蔽之 不会去立刻执行的任务 哪些属于异步任务 settimeout() dom事件 AJAX/AXIOS请求 setinterval() 异步发展阶段回调函数generator()promise 为什么有promise 避免出现回调地狱？？ 它是如何避免的 通过.then的链式调用，从而避免的了不断嵌套的回调地狱 它有哪些状态 pending 初始化的状态 resolved 就是成功执行的状态 resolved会触发then方法 而Then方法所返回的状态为resolved reject 异步任务出错/或是抛出异常的时候 会去触发catch方法 catch所返回的状态还是为resolved 谨记一点就是 promise的状态的改变是不可逆的 一旦成为resolved状态 或是rejected状态 后续改变promise状态的resolve()/reject( )全部失效 有哪些方法 resolve() 这里牢记promise.resolve()所返回的是一个成功状态的promise对象 reject( ) promise.reject()所返回的是失败状态的promise对象 race（） all() async/await 原因 已经有了promise为什么还要有它 这里先记住一点就是，await 一旦出现意味着之后所有的任务全部都是，异步任务，async所声明的函数本身依然属于同步任务","categories":[],"tags":[],"keywords":[]},{"title":"BFC","slug":"BFC","date":"2020-10-30T13:48:45.000Z","updated":"2020-10-30T13:49:06.602Z","comments":true,"path":"2020/10/30/BFC/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/30/BFC/","excerpt":"","text":"为什么设置over-flow:hidden,可以清除浮动 要了解bfc块，内部的块级元素会垂直摆放，同属于一个bfc块会发生margin重叠，那么消除这样的bug就可以给其中一个元素在套一个容器让他成为令一个新的bfc块（还要设置一个over-flow:hidden). 给父元素加了一个over-flow:hidden就是为了使用bfc块的特性：在计算bfc块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。 注意一下如何使用BFC消除margin重叠， 首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的","categories":[],"tags":[],"keywords":[]},{"title":"盒模型","slug":"盒模型","date":"2020-10-30T13:20:47.000Z","updated":"2020-10-30T13:40:09.087Z","comments":true,"path":"2020/10/30/盒模型/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/30/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"首先盒模型有几个属性分别是content border padding margin ; 盒模型有两种标准， 1：第一种是w3c（万维网联盟） 首先盒模型有几个属性分别是content border padding margin ; 它的宽高的计算是包含了border的 第二种：是传统的ie浏览器模型： 也有几个属性分别是content （特殊点就是内容包含了内边距和border） border padding margin ; 但是其元素宽高的计算是包含了border 什么意思，就是说我可以并排的展示两个加上border超出了容器的元素；再具体就是元素的宽高既包含元素本身，还包含了其内部的边框与内边距；","categories":[],"tags":[],"keywords":[]},{"title":"DFS","slug":"DFS","date":"2020-10-30T13:20:47.000Z","updated":"2020-10-30T13:22:46.225Z","comments":true,"path":"2020/10/30/DFS/","link":"","permalink":"https://gitee.com/HEXOS/hexos/2020/10/30/DFS/","excerpt":"","text":"深度优先遍历的思想它会去到达每一个节点后会穷尽这个节点的所有子节点，知道到达叶子节点后，再到上一个节点的另一个孩子节点继续穷尽；怎么做的利用递归–》为什么，原因在于它每一次都会重复，访问根节点，之后再去访问它的子节点，每当访问到它的子节点后，将这个子节点当根节点再去访问它的下一个子节点，意味着，不断的需要去调用自身，所以采取递归，以下为基本的实现12345function dfs(root) &#123; console.log(root.val); if(!root.left)&#123;dfs(root.left)&#125; if(!root.right)&#123;dfs(root.right)&#125;&#125;","categories":[],"tags":[],"keywords":[]}]}